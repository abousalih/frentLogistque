{"ast":null,"code":"import _slicedToArray from \"/Users/mac/Apps/sr-manager/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/mac/Apps/sr-manager/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mac/Apps/sr-manager/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { BYTE } from './byte';\nimport { FrameImpl } from './frame-impl';\nimport { Parser } from './parser';\nimport { StompSocketState } from './types';\nimport { Versions } from './versions';\nimport { augmentWebsocket } from './augment-websocket';\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\n\nexport var StompHandler = /*#__PURE__*/function () {\n  function StompHandler(_client, _webSocket) {\n    var _this = this;\n\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, StompHandler);\n\n    this._client = _client;\n    this._webSocket = _webSocket;\n    this._serverFrameHandlers = {\n      // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n      CONNECTED: function CONNECTED(frame) {\n        _this.debug(\"connected to server \".concat(frame.headers.server));\n\n        _this._connected = true;\n        _this._connectedVersion = frame.headers.version; // STOMP version 1.2 needs header values to be escaped\n\n        if (_this._connectedVersion === Versions.V1_2) {\n          _this._escapeHeaderValues = true;\n        }\n\n        _this._setupHeartbeat(frame.headers);\n\n        _this.onConnect(frame);\n      },\n      // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n      MESSAGE: function MESSAGE(frame) {\n        // the callback is registered when the client calls\n        // `subscribe()`.\n        // If there is no registered subscription for the received message,\n        // the default `onUnhandledMessage` callback is used that the client can set.\n        // This is useful for subscriptions that are automatically created\n        // on the browser side (e.g. [RabbitMQ's temporary\n        // queues](http://www.rabbitmq.com/stomp.html)).\n        var subscription = frame.headers.subscription;\n        var onReceive = _this._subscriptions[subscription] || _this.onUnhandledMessage; // bless the frame to be a Message\n\n        var message = frame;\n        var client = _this;\n        var messageId = _this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id']; // add `ack()` and `nack()` methods directly to the returned frame\n        // so that a simple call to `message.ack()` can acknowledge the message.\n\n        message.ack = function () {\n          var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return client.ack(messageId, subscription, headers);\n        };\n\n        message.nack = function () {\n          var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return client.nack(messageId, subscription, headers);\n        };\n\n        onReceive(message);\n      },\n      // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n      RECEIPT: function RECEIPT(frame) {\n        var callback = _this._receiptWatchers[frame.headers['receipt-id']];\n\n        if (callback) {\n          callback(frame); // Server will acknowledge only once, remove the callback\n\n          delete _this._receiptWatchers[frame.headers['receipt-id']];\n        } else {\n          _this.onUnhandledReceipt(frame);\n        }\n      },\n      // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n      ERROR: function ERROR(frame) {\n        _this.onStompError(frame);\n      }\n    }; // used to index subscribers\n\n    this._counter = 0; // subscription callbacks indexed by subscriber's ID\n\n    this._subscriptions = {}; // receipt-watchers indexed by receipts-ids\n\n    this._receiptWatchers = {};\n    this._partialData = '';\n    this._escapeHeaderValues = false;\n    this._lastServerActivityTS = Date.now();\n    this.configure(config);\n  }\n\n  _createClass(StompHandler, [{\n    key: \"connectedVersion\",\n    get: function get() {\n      return this._connectedVersion;\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this._connected;\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(conf) {\n      // bulk assign all properties to this\n      Object.assign(this, conf);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this2 = this;\n\n      var parser = new Parser( // On Frame\n      function (rawFrame) {\n        var frame = FrameImpl.fromRawFrame(rawFrame, _this2._escapeHeaderValues); // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n\n        if (!_this2.logRawCommunication) {\n          _this2.debug(\"<<< \".concat(frame));\n        }\n\n        var serverFrameHandler = _this2._serverFrameHandlers[frame.command] || _this2.onUnhandledFrame;\n        serverFrameHandler(frame);\n      }, // On Incoming Ping\n      function () {\n        _this2.debug('<<< PONG');\n      });\n\n      this._webSocket.onmessage = function (evt) {\n        _this2.debug('Received data');\n\n        _this2._lastServerActivityTS = Date.now();\n\n        if (_this2.logRawCommunication) {\n          var rawChunkAsString = evt.data instanceof ArrayBuffer ? new TextDecoder().decode(evt.data) : evt.data;\n\n          _this2.debug(\"<<< \".concat(rawChunkAsString));\n        }\n\n        parser.parseChunk(evt.data, _this2.appendMissingNULLonIncoming);\n      };\n\n      this._onclose = function (closeEvent) {\n        _this2.debug(\"Connection closed to \".concat(_this2._client.brokerURL));\n\n        _this2._cleanUp();\n\n        _this2.onWebSocketClose(closeEvent);\n      };\n\n      this._webSocket.onclose = this._onclose;\n\n      this._webSocket.onerror = function (errorEvent) {\n        _this2.onWebSocketError(errorEvent);\n      };\n\n      this._webSocket.onopen = function () {\n        // Clone before updating\n        var connectHeaders = Object.assign({}, _this2.connectHeaders);\n\n        _this2.debug('Web Socket Opened...');\n\n        connectHeaders['accept-version'] = _this2.stompVersions.supportedVersions();\n        connectHeaders['heart-beat'] = [_this2.heartbeatOutgoing, _this2.heartbeatIncoming].join(',');\n\n        _this2._transmit({\n          command: 'CONNECT',\n          headers: connectHeaders\n        });\n      };\n    }\n  }, {\n    key: \"_setupHeartbeat\",\n    value: function _setupHeartbeat(headers) {\n      var _this3 = this;\n\n      if (headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2) {\n        return;\n      } // It is valid for the server to not send this header\n      // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n\n\n      if (!headers['heart-beat']) {\n        return;\n      } // heart-beat header received from the server looks like:\n      //\n      //     heart-beat: sx, sy\n\n\n      var _headers$heartBeat$s = headers['heart-beat'].split(',').map(function (v) {\n        return parseInt(v, 10);\n      }),\n          _headers$heartBeat$s2 = _slicedToArray(_headers$heartBeat$s, 2),\n          serverOutgoing = _headers$heartBeat$s2[0],\n          serverIncoming = _headers$heartBeat$s2[1];\n\n      if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n        var ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n        this.debug(\"send PING every \".concat(ttl, \"ms\"));\n        this._pinger = setInterval(function () {\n          if (_this3._webSocket.readyState === StompSocketState.OPEN) {\n            _this3._webSocket.send(BYTE.LF);\n\n            _this3.debug('>>> PING');\n          }\n        }, ttl);\n      }\n\n      if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n        var _ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n\n        this.debug(\"check PONG every \".concat(_ttl, \"ms\"));\n        this._ponger = setInterval(function () {\n          var delta = Date.now() - _this3._lastServerActivityTS; // We wait twice the TTL to be flexible on window's setInterval calls\n\n\n          if (delta > _ttl * 2) {\n            _this3.debug(\"did not receive server activity for the last \".concat(delta, \"ms\"));\n\n            _this3._closeOrDiscardWebsocket();\n          }\n        }, _ttl);\n      }\n    }\n  }, {\n    key: \"_closeOrDiscardWebsocket\",\n    value: function _closeOrDiscardWebsocket() {\n      if (this.discardWebsocketOnCommFailure) {\n        this.debug('Discarding websocket, the underlying socket may linger for a while');\n\n        this._discardWebsocket();\n      } else {\n        this.debug('Issuing close on the websocket');\n\n        this._closeWebsocket();\n      }\n    }\n  }, {\n    key: \"forceDisconnect\",\n    value: function forceDisconnect() {\n      if (this._webSocket) {\n        if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n          this._closeOrDiscardWebsocket();\n        }\n      }\n    }\n  }, {\n    key: \"_closeWebsocket\",\n    value: function _closeWebsocket() {\n      this._webSocket.onmessage = function () {}; // ignore messages\n\n\n      this._webSocket.close();\n    }\n  }, {\n    key: \"_discardWebsocket\",\n    value: function _discardWebsocket() {\n      var _this4 = this;\n\n      if (!this._webSocket.terminate) {\n        augmentWebsocket(this._webSocket, function (msg) {\n          return _this4.debug(msg);\n        });\n      }\n\n      this._webSocket.terminate();\n    }\n  }, {\n    key: \"_transmit\",\n    value: function _transmit(params) {\n      var command = params.command,\n          headers = params.headers,\n          body = params.body,\n          binaryBody = params.binaryBody,\n          skipContentLengthHeader = params.skipContentLengthHeader;\n      var frame = new FrameImpl({\n        command: command,\n        headers: headers,\n        body: body,\n        binaryBody: binaryBody,\n        escapeHeaderValues: this._escapeHeaderValues,\n        skipContentLengthHeader: skipContentLengthHeader\n      });\n      var rawChunk = frame.serialize();\n\n      if (this.logRawCommunication) {\n        this.debug(\">>> \".concat(rawChunk));\n      } else {\n        this.debug(\">>> \".concat(frame));\n      }\n\n      if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n        rawChunk = new TextEncoder().encode(rawChunk);\n      }\n\n      if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n        this._webSocket.send(rawChunk);\n      } else {\n        var out = rawChunk;\n\n        while (out.length > 0) {\n          var chunk = out.substring(0, this.maxWebSocketChunkSize);\n          out = out.substring(this.maxWebSocketChunkSize);\n\n          this._webSocket.send(chunk);\n\n          this.debug(\"chunk sent = \".concat(chunk.length, \", remaining = \").concat(out.length));\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this5 = this;\n\n      if (this.connected) {\n        try {\n          // clone before updating\n          var disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n\n          if (!disconnectHeaders.receipt) {\n            disconnectHeaders.receipt = \"close-\".concat(this._counter++);\n          }\n\n          this.watchForReceipt(disconnectHeaders.receipt, function (frame) {\n            _this5._closeWebsocket();\n\n            _this5._cleanUp();\n\n            _this5.onDisconnect(frame);\n          });\n\n          this._transmit({\n            command: 'DISCONNECT',\n            headers: disconnectHeaders\n          });\n        } catch (error) {\n          this.debug(\"Ignoring error during disconnect \".concat(error));\n        }\n      } else {\n        if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n          this._closeWebsocket();\n        }\n      }\n    }\n  }, {\n    key: \"_cleanUp\",\n    value: function _cleanUp() {\n      this._connected = false;\n\n      if (this._pinger) {\n        clearInterval(this._pinger);\n      }\n\n      if (this._ponger) {\n        clearInterval(this._ponger);\n      }\n    }\n  }, {\n    key: \"publish\",\n    value: function publish(params) {\n      var destination = params.destination,\n          headers = params.headers,\n          body = params.body,\n          binaryBody = params.binaryBody,\n          skipContentLengthHeader = params.skipContentLengthHeader;\n      var hdrs = Object.assign({\n        destination: destination\n      }, headers);\n\n      this._transmit({\n        command: 'SEND',\n        headers: hdrs,\n        body: body,\n        binaryBody: binaryBody,\n        skipContentLengthHeader: skipContentLengthHeader\n      });\n    }\n  }, {\n    key: \"watchForReceipt\",\n    value: function watchForReceipt(receiptId, callback) {\n      this._receiptWatchers[receiptId] = callback;\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(destination, callback) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      headers = Object.assign({}, headers);\n\n      if (!headers.id) {\n        headers.id = \"sub-\".concat(this._counter++);\n      }\n\n      headers.destination = destination;\n      this._subscriptions[headers.id] = callback;\n\n      this._transmit({\n        command: 'SUBSCRIBE',\n        headers: headers\n      });\n\n      var client = this;\n      return {\n        id: headers.id,\n        unsubscribe: function unsubscribe(hdrs) {\n          return client.unsubscribe(headers.id, hdrs);\n        }\n      };\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(id) {\n      var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      headers = Object.assign({}, headers);\n      delete this._subscriptions[id];\n      headers.id = id;\n\n      this._transmit({\n        command: 'UNSUBSCRIBE',\n        headers: headers\n      });\n    }\n  }, {\n    key: \"begin\",\n    value: function begin(transactionId) {\n      var txId = transactionId || \"tx-\".concat(this._counter++);\n\n      this._transmit({\n        command: 'BEGIN',\n        headers: {\n          transaction: txId\n        }\n      });\n\n      var client = this;\n      return {\n        id: txId,\n        commit: function commit() {\n          client.commit(txId);\n        },\n        abort: function abort() {\n          client.abort(txId);\n        }\n      };\n    }\n  }, {\n    key: \"commit\",\n    value: function commit(transactionId) {\n      this._transmit({\n        command: 'COMMIT',\n        headers: {\n          transaction: transactionId\n        }\n      });\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(transactionId) {\n      this._transmit({\n        command: 'ABORT',\n        headers: {\n          transaction: transactionId\n        }\n      });\n    }\n  }, {\n    key: \"ack\",\n    value: function ack(messageId, subscriptionId) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      headers = Object.assign({}, headers);\n\n      if (this._connectedVersion === Versions.V1_2) {\n        headers.id = messageId;\n      } else {\n        headers['message-id'] = messageId;\n      }\n\n      headers.subscription = subscriptionId;\n\n      this._transmit({\n        command: 'ACK',\n        headers: headers\n      });\n    }\n  }, {\n    key: \"nack\",\n    value: function nack(messageId, subscriptionId) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      headers = Object.assign({}, headers);\n\n      if (this._connectedVersion === Versions.V1_2) {\n        headers.id = messageId;\n      } else {\n        headers['message-id'] = messageId;\n      }\n\n      headers.subscription = subscriptionId;\n      return this._transmit({\n        command: 'NACK',\n        headers: headers\n      });\n    }\n  }]);\n\n  return StompHandler;\n}(); //# sourceMappingURL=stomp-handler.js.map","map":{"version":3,"sources":["/Users/mac/Apps/sr-manager/frontend/node_modules/@stomp/stompjs/esm6/stomp-handler.js"],"names":["BYTE","FrameImpl","Parser","StompSocketState","Versions","augmentWebsocket","StompHandler","_client","_webSocket","config","_serverFrameHandlers","CONNECTED","frame","debug","headers","server","_connected","_connectedVersion","version","V1_2","_escapeHeaderValues","_setupHeartbeat","onConnect","MESSAGE","subscription","onReceive","_subscriptions","onUnhandledMessage","message","client","messageId","ack","nack","RECEIPT","callback","_receiptWatchers","onUnhandledReceipt","ERROR","onStompError","_counter","_partialData","_lastServerActivityTS","Date","now","configure","conf","Object","assign","parser","rawFrame","fromRawFrame","logRawCommunication","serverFrameHandler","command","onUnhandledFrame","onmessage","evt","rawChunkAsString","data","ArrayBuffer","TextDecoder","decode","parseChunk","appendMissingNULLonIncoming","_onclose","closeEvent","brokerURL","_cleanUp","onWebSocketClose","onclose","onerror","errorEvent","onWebSocketError","onopen","connectHeaders","stompVersions","supportedVersions","heartbeatOutgoing","heartbeatIncoming","join","_transmit","V1_1","split","map","v","parseInt","serverOutgoing","serverIncoming","ttl","Math","max","_pinger","setInterval","readyState","OPEN","send","LF","_ponger","delta","_closeOrDiscardWebsocket","discardWebsocketOnCommFailure","_discardWebsocket","_closeWebsocket","CONNECTING","close","terminate","msg","params","body","binaryBody","skipContentLengthHeader","escapeHeaderValues","rawChunk","serialize","forceBinaryWSFrames","TextEncoder","encode","splitLargeFrames","out","length","chunk","substring","maxWebSocketChunkSize","connected","disconnectHeaders","receipt","watchForReceipt","onDisconnect","error","clearInterval","destination","hdrs","receiptId","id","unsubscribe","transactionId","txId","transaction","commit","abort","subscriptionId"],"mappings":"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","sourcesContent":["import { BYTE } from './byte';\nimport { FrameImpl } from './frame-impl';\nimport { Parser } from './parser';\nimport { StompSocketState, } from './types';\nimport { Versions } from './versions';\nimport { augmentWebsocket } from './augment-websocket';\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class StompHandler {\n    constructor(_client, _webSocket, config = {}) {\n        this._client = _client;\n        this._webSocket = _webSocket;\n        this._serverFrameHandlers = {\n            // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n            CONNECTED: frame => {\n                this.debug(`connected to server ${frame.headers.server}`);\n                this._connected = true;\n                this._connectedVersion = frame.headers.version;\n                // STOMP version 1.2 needs header values to be escaped\n                if (this._connectedVersion === Versions.V1_2) {\n                    this._escapeHeaderValues = true;\n                }\n                this._setupHeartbeat(frame.headers);\n                this.onConnect(frame);\n            },\n            // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n            MESSAGE: frame => {\n                // the callback is registered when the client calls\n                // `subscribe()`.\n                // If there is no registered subscription for the received message,\n                // the default `onUnhandledMessage` callback is used that the client can set.\n                // This is useful for subscriptions that are automatically created\n                // on the browser side (e.g. [RabbitMQ's temporary\n                // queues](http://www.rabbitmq.com/stomp.html)).\n                const subscription = frame.headers.subscription;\n                const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\n                // bless the frame to be a Message\n                const message = frame;\n                const client = this;\n                const messageId = this._connectedVersion === Versions.V1_2\n                    ? message.headers.ack\n                    : message.headers['message-id'];\n                // add `ack()` and `nack()` methods directly to the returned frame\n                // so that a simple call to `message.ack()` can acknowledge the message.\n                message.ack = (headers = {}) => {\n                    return client.ack(messageId, subscription, headers);\n                };\n                message.nack = (headers = {}) => {\n                    return client.nack(messageId, subscription, headers);\n                };\n                onReceive(message);\n            },\n            // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n            RECEIPT: frame => {\n                const callback = this._receiptWatchers[frame.headers['receipt-id']];\n                if (callback) {\n                    callback(frame);\n                    // Server will acknowledge only once, remove the callback\n                    delete this._receiptWatchers[frame.headers['receipt-id']];\n                }\n                else {\n                    this.onUnhandledReceipt(frame);\n                }\n            },\n            // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n            ERROR: frame => {\n                this.onStompError(frame);\n            },\n        };\n        // used to index subscribers\n        this._counter = 0;\n        // subscription callbacks indexed by subscriber's ID\n        this._subscriptions = {};\n        // receipt-watchers indexed by receipts-ids\n        this._receiptWatchers = {};\n        this._partialData = '';\n        this._escapeHeaderValues = false;\n        this._lastServerActivityTS = Date.now();\n        this.configure(config);\n    }\n    get connectedVersion() {\n        return this._connectedVersion;\n    }\n    get connected() {\n        return this._connected;\n    }\n    configure(conf) {\n        // bulk assign all properties to this\n        Object.assign(this, conf);\n    }\n    start() {\n        const parser = new Parser(\n        // On Frame\n        rawFrame => {\n            const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues);\n            // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n            if (!this.logRawCommunication) {\n                this.debug(`<<< ${frame}`);\n            }\n            const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n            serverFrameHandler(frame);\n        }, \n        // On Incoming Ping\n        () => {\n            this.debug('<<< PONG');\n        });\n        this._webSocket.onmessage = (evt) => {\n            this.debug('Received data');\n            this._lastServerActivityTS = Date.now();\n            if (this.logRawCommunication) {\n                const rawChunkAsString = evt.data instanceof ArrayBuffer\n                    ? new TextDecoder().decode(evt.data)\n                    : evt.data;\n                this.debug(`<<< ${rawChunkAsString}`);\n            }\n            parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n        };\n        this._onclose = (closeEvent) => {\n            this.debug(`Connection closed to ${this._client.brokerURL}`);\n            this._cleanUp();\n            this.onWebSocketClose(closeEvent);\n        };\n        this._webSocket.onclose = this._onclose;\n        this._webSocket.onerror = (errorEvent) => {\n            this.onWebSocketError(errorEvent);\n        };\n        this._webSocket.onopen = () => {\n            // Clone before updating\n            const connectHeaders = Object.assign({}, this.connectHeaders);\n            this.debug('Web Socket Opened...');\n            connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n            connectHeaders['heart-beat'] = [\n                this.heartbeatOutgoing,\n                this.heartbeatIncoming,\n            ].join(',');\n            this._transmit({ command: 'CONNECT', headers: connectHeaders });\n        };\n    }\n    _setupHeartbeat(headers) {\n        if (headers.version !== Versions.V1_1 &&\n            headers.version !== Versions.V1_2) {\n            return;\n        }\n        // It is valid for the server to not send this header\n        // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n        if (!headers['heart-beat']) {\n            return;\n        }\n        // heart-beat header received from the server looks like:\n        //\n        //     heart-beat: sx, sy\n        const [serverOutgoing, serverIncoming] = headers['heart-beat']\n            .split(',')\n            .map((v) => parseInt(v, 10));\n        if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n            const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n            this.debug(`send PING every ${ttl}ms`);\n            this._pinger = setInterval(() => {\n                if (this._webSocket.readyState === StompSocketState.OPEN) {\n                    this._webSocket.send(BYTE.LF);\n                    this.debug('>>> PING');\n                }\n            }, ttl);\n        }\n        if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n            const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n            this.debug(`check PONG every ${ttl}ms`);\n            this._ponger = setInterval(() => {\n                const delta = Date.now() - this._lastServerActivityTS;\n                // We wait twice the TTL to be flexible on window's setInterval calls\n                if (delta > ttl * 2) {\n                    this.debug(`did not receive server activity for the last ${delta}ms`);\n                    this._closeOrDiscardWebsocket();\n                }\n            }, ttl);\n        }\n    }\n    _closeOrDiscardWebsocket() {\n        if (this.discardWebsocketOnCommFailure) {\n            this.debug('Discarding websocket, the underlying socket may linger for a while');\n            this._discardWebsocket();\n        }\n        else {\n            this.debug('Issuing close on the websocket');\n            this._closeWebsocket();\n        }\n    }\n    forceDisconnect() {\n        if (this._webSocket) {\n            if (this._webSocket.readyState === StompSocketState.CONNECTING ||\n                this._webSocket.readyState === StompSocketState.OPEN) {\n                this._closeOrDiscardWebsocket();\n            }\n        }\n    }\n    _closeWebsocket() {\n        this._webSocket.onmessage = () => { }; // ignore messages\n        this._webSocket.close();\n    }\n    _discardWebsocket() {\n        if (!this._webSocket.terminate) {\n            augmentWebsocket(this._webSocket, (msg) => this.debug(msg));\n        }\n        this._webSocket.terminate();\n    }\n    _transmit(params) {\n        const { command, headers, body, binaryBody, skipContentLengthHeader } = params;\n        const frame = new FrameImpl({\n            command,\n            headers,\n            body,\n            binaryBody,\n            escapeHeaderValues: this._escapeHeaderValues,\n            skipContentLengthHeader,\n        });\n        let rawChunk = frame.serialize();\n        if (this.logRawCommunication) {\n            this.debug(`>>> ${rawChunk}`);\n        }\n        else {\n            this.debug(`>>> ${frame}`);\n        }\n        if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n            rawChunk = new TextEncoder().encode(rawChunk);\n        }\n        if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n            this._webSocket.send(rawChunk);\n        }\n        else {\n            let out = rawChunk;\n            while (out.length > 0) {\n                const chunk = out.substring(0, this.maxWebSocketChunkSize);\n                out = out.substring(this.maxWebSocketChunkSize);\n                this._webSocket.send(chunk);\n                this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n            }\n        }\n    }\n    dispose() {\n        if (this.connected) {\n            try {\n                // clone before updating\n                const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n                if (!disconnectHeaders.receipt) {\n                    disconnectHeaders.receipt = `close-${this._counter++}`;\n                }\n                this.watchForReceipt(disconnectHeaders.receipt, frame => {\n                    this._closeWebsocket();\n                    this._cleanUp();\n                    this.onDisconnect(frame);\n                });\n                this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\n            }\n            catch (error) {\n                this.debug(`Ignoring error during disconnect ${error}`);\n            }\n        }\n        else {\n            if (this._webSocket.readyState === StompSocketState.CONNECTING ||\n                this._webSocket.readyState === StompSocketState.OPEN) {\n                this._closeWebsocket();\n            }\n        }\n    }\n    _cleanUp() {\n        this._connected = false;\n        if (this._pinger) {\n            clearInterval(this._pinger);\n        }\n        if (this._ponger) {\n            clearInterval(this._ponger);\n        }\n    }\n    publish(params) {\n        const { destination, headers, body, binaryBody, skipContentLengthHeader } = params;\n        const hdrs = Object.assign({ destination }, headers);\n        this._transmit({\n            command: 'SEND',\n            headers: hdrs,\n            body,\n            binaryBody,\n            skipContentLengthHeader,\n        });\n    }\n    watchForReceipt(receiptId, callback) {\n        this._receiptWatchers[receiptId] = callback;\n    }\n    subscribe(destination, callback, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (!headers.id) {\n            headers.id = `sub-${this._counter++}`;\n        }\n        headers.destination = destination;\n        this._subscriptions[headers.id] = callback;\n        this._transmit({ command: 'SUBSCRIBE', headers });\n        const client = this;\n        return {\n            id: headers.id,\n            unsubscribe(hdrs) {\n                return client.unsubscribe(headers.id, hdrs);\n            },\n        };\n    }\n    unsubscribe(id, headers = {}) {\n        headers = Object.assign({}, headers);\n        delete this._subscriptions[id];\n        headers.id = id;\n        this._transmit({ command: 'UNSUBSCRIBE', headers });\n    }\n    begin(transactionId) {\n        const txId = transactionId || `tx-${this._counter++}`;\n        this._transmit({\n            command: 'BEGIN',\n            headers: {\n                transaction: txId,\n            },\n        });\n        const client = this;\n        return {\n            id: txId,\n            commit() {\n                client.commit(txId);\n            },\n            abort() {\n                client.abort(txId);\n            },\n        };\n    }\n    commit(transactionId) {\n        this._transmit({\n            command: 'COMMIT',\n            headers: {\n                transaction: transactionId,\n            },\n        });\n    }\n    abort(transactionId) {\n        this._transmit({\n            command: 'ABORT',\n            headers: {\n                transaction: transactionId,\n            },\n        });\n    }\n    ack(messageId, subscriptionId, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (this._connectedVersion === Versions.V1_2) {\n            headers.id = messageId;\n        }\n        else {\n            headers['message-id'] = messageId;\n        }\n        headers.subscription = subscriptionId;\n        this._transmit({ command: 'ACK', headers });\n    }\n    nack(messageId, subscriptionId, headers = {}) {\n        headers = Object.assign({}, headers);\n        if (this._connectedVersion === Versions.V1_2) {\n            headers.id = messageId;\n        }\n        else {\n            headers['message-id'] = messageId;\n        }\n        headers.subscription = subscriptionId;\n        return this._transmit({ command: 'NACK', headers });\n    }\n}\n//# sourceMappingURL=stomp-handler.js.map"]},"metadata":{},"sourceType":"module"}