{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/mac/Apps/sr-manager/web/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/Users/mac/Apps/sr-manager/web/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/Users/mac/Apps/sr-manager/web/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/mac/Apps/sr-manager/web/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mac/Apps/sr-manager/web/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar _keys;\n\nimport { Directive, TemplateRef, ViewContainerRef, Input, Injectable, ɵɵdefineInjectable, Component, ViewEncapsulation, ElementRef, EventEmitter, ContentChild, ViewChild, Output, HostListener, Renderer2, NgZone, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { autorun, reaction, computed as computed$1, observable as observable$1, action as action$1 } from 'mobx';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction LoadingComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1, \"loading...\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nvar _c0 = function _c0(a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction TreeViewportComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\");\n    ɵngcc0.ɵɵprojection(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"height\", ctx_r0.getTotalHeight());\n  }\n}\n\nvar _c1 = function _c1() {\n  return {\n    dontDetach: true\n  };\n};\n\nvar _c2 = [\"*\"];\nvar _c3 = [\"loadingTemplate\"];\nvar _c4 = [\"treeNodeTemplate\"];\nvar _c5 = [\"treeNodeWrapperTemplate\"];\nvar _c6 = [\"treeNodeFullTemplate\"];\nvar _c7 = [\"viewport\"];\n\nvar _c8 = function _c8(a0, a1, a2, a3) {\n  return {\n    loadingTemplate: a0,\n    treeNodeTemplate: a1,\n    treeNodeWrapperTemplate: a2,\n    treeNodeFullTemplate: a3\n  };\n};\n\nfunction TreeComponent_tree_node_collection_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-collection\", 4);\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"nodes\", ctx_r1.treeModel.roots)(\"treeModel\", ctx_r1.treeModel)(\"templates\", ɵngcc0.ɵɵpureFunction4(3, _c8, ctx_r1.loadingTemplate, ctx_r1.treeNodeTemplate, ctx_r1.treeNodeWrapperTemplate, ctx_r1.treeNodeFullTemplate));\n  }\n}\n\nfunction TreeComponent_tree_node_drop_slot_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-drop-slot\", 5);\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"dropIndex\", 0)(\"node\", ctx_r2.treeModel.virtualRoot);\n  }\n}\n\nfunction TreeNodeComponent_ng_container_0_div_1_tree_node_drop_slot_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-drop-slot\", 6);\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵproperty(\"dropIndex\", ctx_r2.node.index)(\"node\", ctx_r2.node.parent);\n  }\n}\n\nfunction TreeNodeComponent_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\");\n    ɵngcc0.ɵɵtemplate(1, TreeNodeComponent_ng_container_0_div_1_tree_node_drop_slot_1_Template, 1, 2, \"tree-node-drop-slot\", 3);\n    ɵngcc0.ɵɵelement(2, \"tree-node-wrapper\", 4);\n    ɵngcc0.ɵɵelement(3, \"tree-node-children\", 5);\n    ɵngcc0.ɵɵelement(4, \"tree-node-drop-slot\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassMap(ctx_r1.node.getClass());\n    ɵngcc0.ɵɵclassProp(\"tree-node\", true)(\"tree-node-expanded\", ctx_r1.node.isExpanded && ctx_r1.node.hasChildren)(\"tree-node-collapsed\", ctx_r1.node.isCollapsed && ctx_r1.node.hasChildren)(\"tree-node-leaf\", ctx_r1.node.isLeaf)(\"tree-node-active\", ctx_r1.node.isActive)(\"tree-node-focused\", ctx_r1.node.isFocused);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.index === 0);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r1.node)(\"index\", ctx_r1.index)(\"templates\", ctx_r1.templates);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r1.node)(\"templates\", ctx_r1.templates);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"dropIndex\", ctx_r1.node.index + 1)(\"node\", ctx_r1.node.parent);\n  }\n}\n\nvar _c9 = function _c9(a0, a1, a2, a3) {\n  return {\n    $implicit: a0,\n    node: a1,\n    index: a2,\n    templates: a3\n  };\n};\n\nfunction TreeNodeComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TreeNodeComponent_ng_container_0_div_1_Template, 5, 22, \"div\", 1);\n    ɵngcc0.ɵɵelementContainer(2, 2);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.templates.treeNodeFullTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.templates.treeNodeFullTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction4(3, _c9, ctx_r0.node, ctx_r0.node, ctx_r0.index, ctx_r0.templates));\n  }\n}\n\nfunction TreeNodeContent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.node.displayField);\n  }\n}\n\nvar _c10 = function _c10(a0, a1, a2) {\n  return {\n    $implicit: a0,\n    node: a1,\n    index: a2\n  };\n};\n\nfunction TreeNodeExpanderComponent_ng_container_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r4 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 3);\n    ɵngcc0.ɵɵlistener(\"click\", function TreeNodeExpanderComponent_ng_container_0_span_1_Template_span_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r4);\n      var ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r3.node.mouseAction(\"expanderClick\", $event);\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 4);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"toggle-children-wrapper-expanded\", ctx_r1.node.isExpanded)(\"toggle-children-wrapper-collapsed\", ctx_r1.node.isCollapsed);\n  }\n}\n\nfunction TreeNodeExpanderComponent_ng_container_0_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 5);\n  }\n}\n\nfunction TreeNodeExpanderComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TreeNodeExpanderComponent_ng_container_0_span_1_Template, 2, 4, \"span\", 1);\n    ɵngcc0.ɵɵtemplate(2, TreeNodeExpanderComponent_ng_container_0_span_2_Template, 1, 0, \"span\", 2);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.node.hasChildren);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.node.hasChildren);\n  }\n}\n\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_tree_node_collection_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-collection\", 4);\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵproperty(\"nodes\", ctx_r2.node.children)(\"templates\", ctx_r2.templates)(\"treeModel\", ctx_r2.node.treeModel);\n  }\n}\n\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_tree_loading_component_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-loading-component\", 5);\n  }\n\n  if (rf & 2) {\n    var ctx_r3 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵstyleProp(\"padding-left\", ctx_r3.node.getNodePadding());\n    ɵngcc0.ɵɵproperty(\"template\", ctx_r3.templates.loadingTemplate)(\"node\", ctx_r3.node);\n  }\n}\n\nfunction TreeNodeChildrenComponent_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\");\n    ɵngcc0.ɵɵtemplate(1, TreeNodeChildrenComponent_ng_container_0_div_1_tree_node_collection_1_Template, 1, 3, \"tree-node-collection\", 2);\n    ɵngcc0.ɵɵtemplate(2, TreeNodeChildrenComponent_ng_container_0_div_1_tree_loading_component_2_Template, 1, 4, \"tree-loading-component\", 3);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"tree-children\", true)(\"tree-children-no-padding\", ctx_r1.node.options.levelPadding);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.node.children);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.node.children);\n  }\n}\n\nfunction TreeNodeChildrenComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TreeNodeChildrenComponent_ng_container_0_div_1_Template, 3, 6, \"div\", 1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"treeAnimateOpen\", ctx_r0.node.isExpanded)(\"treeAnimateOpenSpeed\", ctx_r0.node.options.animateSpeed)(\"treeAnimateOpenAcceleration\", ctx_r0.node.options.animateAcceleration)(\"treeAnimateOpenEnabled\", ctx_r0.node.options.animateExpand);\n  }\n}\n\nfunction TreeNodeCollectionComponent_ng_container_0_tree_node_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node\", 2);\n  }\n\n  if (rf & 2) {\n    var node_r2 = ctx.$implicit;\n    var i_r3 = ctx.index;\n    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"node\", node_r2)(\"index\", i_r3)(\"templates\", ctx_r1.templates);\n  }\n}\n\nfunction TreeNodeCollectionComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\");\n    ɵngcc0.ɵɵtemplate(2, TreeNodeCollectionComponent_ng_container_0_tree_node_2_Template, 1, 3, \"tree-node\", 1);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"margin-top\", ctx_r0.marginTop);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.viewportNodes)(\"ngForTrackBy\", ctx_r0.trackNode);\n  }\n}\n\nfunction TreeNodeWrapperComponent_div_0_tree_node_checkbox_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tree-node-checkbox\", 4);\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r1.node);\n  }\n}\n\nfunction TreeNodeWrapperComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r3 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2);\n    ɵngcc0.ɵɵtemplate(1, TreeNodeWrapperComponent_div_0_tree_node_checkbox_1_Template, 1, 1, \"tree-node-checkbox\", 3);\n    ɵngcc0.ɵɵelement(2, \"tree-node-expander\", 4);\n    ɵngcc0.ɵɵelementStart(3, \"div\", 5);\n    ɵngcc0.ɵɵlistener(\"click\", function TreeNodeWrapperComponent_div_0_Template_div_click_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ctx_r2.node.mouseAction(\"click\", $event);\n    })(\"dblclick\", function TreeNodeWrapperComponent_div_0_Template_div_dblclick_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.node.mouseAction(\"dblClick\", $event);\n    })(\"mouseover\", function TreeNodeWrapperComponent_div_0_Template_div_mouseover_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r5 = ɵngcc0.ɵɵnextContext();\n      return ctx_r5.node.mouseAction(\"mouseOver\", $event);\n    })(\"mouseout\", function TreeNodeWrapperComponent_div_0_Template_div_mouseout_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.node.mouseAction(\"mouseOut\", $event);\n    })(\"contextmenu\", function TreeNodeWrapperComponent_div_0_Template_div_contextmenu_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ctx_r7.node.mouseAction(\"contextMenu\", $event);\n    })(\"treeDrop\", function TreeNodeWrapperComponent_div_0_Template_div_treeDrop_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.node.onDrop($event);\n    })(\"treeDropDragOver\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragOver_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.node.mouseAction(\"dragOver\", $event);\n    })(\"treeDropDragLeave\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragLeave_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10.node.mouseAction(\"dragLeave\", $event);\n    })(\"treeDropDragEnter\", function TreeNodeWrapperComponent_div_0_Template_div_treeDropDragEnter_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11.node.mouseAction(\"dragEnter\", $event);\n    });\n    ɵngcc0.ɵɵelement(4, \"tree-node-content\", 6);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵstyleProp(\"padding-left\", ctx_r0.node.getNodePadding());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.node.options.useCheckbox);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r0.node);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"node-content-wrapper-active\", ctx_r0.node.isActive)(\"node-content-wrapper-focused\", ctx_r0.node.isFocused);\n    ɵngcc0.ɵɵproperty(\"treeAllowDrop\", ctx_r0.node.allowDrop)(\"allowDragoverStyling\", ctx_r0.node.allowDragoverStyling())(\"treeDrag\", ctx_r0.node)(\"treeDragEnabled\", ctx_r0.node.allowDrag());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"node\", ctx_r0.node)(\"index\", ctx_r0.index)(\"template\", ctx_r0.templates.treeNodeTemplate);\n  }\n}\n\nfunction TreeNodeCheckboxComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"input\", 1);\n    ɵngcc0.ɵɵlistener(\"click\", function TreeNodeCheckboxComponent_ng_container_0_Template_input_click_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      var ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1.node.mouseAction(\"checkboxClick\", $event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"checked\", ctx_r0.node.isSelected)(\"indeterminate\", ctx_r0.node.isPartiallySelected);\n  }\n}\n\nvar TreeMobxAutorunDirective = /*@__PURE__*/function () {\n  var TreeMobxAutorunDirective = /*#__PURE__*/function () {\n    function TreeMobxAutorunDirective(templateRef, viewContainer) {\n      _classCallCheck(this, TreeMobxAutorunDirective);\n\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n      this.templateBindings = {};\n    }\n\n    _createClass(TreeMobxAutorunDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.view = this.viewContainer.createEmbeddedView(this.templateRef);\n\n        if (this.dispose) {\n          this.dispose();\n        }\n\n        if (this.shouldDetach()) {\n          this.view.detach();\n        }\n\n        this.autoDetect(this.view);\n      }\n    }, {\n      key: \"shouldDetach\",\n      value: function shouldDetach() {\n        return this.treeMobxAutorun && this.treeMobxAutorun.detach;\n      }\n    }, {\n      key: \"autoDetect\",\n      value: function autoDetect(view) {\n        this.dispose = autorun(function () {\n          return view.detectChanges();\n        });\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.dispose) {\n          this.dispose();\n        }\n      }\n    }]);\n\n    return TreeMobxAutorunDirective;\n  }();\n\n  TreeMobxAutorunDirective.ɵfac = function TreeMobxAutorunDirective_Factory(t) {\n    return new (t || TreeMobxAutorunDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  TreeMobxAutorunDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeMobxAutorunDirective,\n    selectors: [[\"\", \"treeMobxAutorun\", \"\"]],\n    inputs: {\n      treeMobxAutorun: \"treeMobxAutorun\"\n    }\n  });\n  return TreeMobxAutorunDirective;\n}();\n\nvar KEYS = {\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  ENTER: 13,\n  SPACE: 32,\n  CONTEXT_MENU: 32\n};\n\nvar ɵ0 = function ɵ0(tree, node, $event) {\n  return node && node.toggleActivated();\n},\n    ɵ1 = function ɵ1(tree, node, $event) {\n  return node && node.toggleActivated(true);\n},\n    ɵ2 = function ɵ2(tree, node, $event) {\n  return node && node.toggleSelected();\n},\n    ɵ3 = function ɵ3(tree, node, $event) {\n  return node.setIsActive(true);\n},\n    ɵ4 = function ɵ4(tree, node, $event) {\n  return node.setIsActive(false);\n},\n    ɵ5 = function ɵ5(tree, node, $event) {\n  return node.setIsSelected(true);\n},\n    ɵ6 = function ɵ6(tree, node, $event) {\n  return node.setIsSelected(false);\n},\n    ɵ7 = function ɵ7(tree, node, $event) {\n  return node.focus();\n},\n    ɵ8 = function ɵ8(tree, node, $event) {\n  return node.hasChildren && node.toggleExpanded();\n},\n    ɵ9 = function ɵ9(tree, node, $event) {\n  return node.expand();\n},\n    ɵ10 = function ɵ10(tree, node, $event) {\n  return node.collapse();\n},\n    ɵ11 = function ɵ11(tree, node, $event) {\n  return tree.focusDrillDown();\n},\n    ɵ12 = function ɵ12(tree, node, $event) {\n  return tree.focusDrillUp();\n},\n    ɵ13 = function ɵ13(tree, node, $event) {\n  return tree.focusNextNode();\n},\n    ɵ14 = function ɵ14(tree, node, $event) {\n  return tree.focusPreviousNode();\n},\n    ɵ15 = function ɵ15(tree, node, $event, _ref) {\n  var from = _ref.from,\n      to = _ref.to;\n\n  // default action assumes from = node, to = {parent, index}\n  if ($event.ctrlKey) {\n    tree.copyNode(from, to);\n  } else {\n    tree.moveNode(from, to);\n  }\n};\n\nvar TREE_ACTIONS = {\n  TOGGLE_ACTIVE: ɵ0,\n  TOGGLE_ACTIVE_MULTI: ɵ1,\n  TOGGLE_SELECTED: ɵ2,\n  ACTIVATE: ɵ3,\n  DEACTIVATE: ɵ4,\n  SELECT: ɵ5,\n  DESELECT: ɵ6,\n  FOCUS: ɵ7,\n  TOGGLE_EXPANDED: ɵ8,\n  EXPAND: ɵ9,\n  COLLAPSE: ɵ10,\n  DRILL_DOWN: ɵ11,\n  DRILL_UP: ɵ12,\n  NEXT_NODE: ɵ13,\n  PREVIOUS_NODE: ɵ14,\n  MOVE_NODE: ɵ15\n};\nvar defaultActionMapping = {\n  mouse: {\n    click: TREE_ACTIONS.TOGGLE_ACTIVE,\n    dblClick: null,\n    contextMenu: null,\n    expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,\n    checkboxClick: TREE_ACTIONS.TOGGLE_SELECTED,\n    drop: TREE_ACTIONS.MOVE_NODE\n  },\n  keys: (_keys = {}, _defineProperty(_keys, KEYS.RIGHT, TREE_ACTIONS.DRILL_DOWN), _defineProperty(_keys, KEYS.LEFT, TREE_ACTIONS.DRILL_UP), _defineProperty(_keys, KEYS.DOWN, TREE_ACTIONS.NEXT_NODE), _defineProperty(_keys, KEYS.UP, TREE_ACTIONS.PREVIOUS_NODE), _defineProperty(_keys, KEYS.SPACE, TREE_ACTIONS.TOGGLE_ACTIVE), _defineProperty(_keys, KEYS.ENTER, TREE_ACTIONS.TOGGLE_ACTIVE), _keys)\n};\n\nvar TreeOptions = /*#__PURE__*/function () {\n  function TreeOptions() {\n    var _keys2;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TreeOptions);\n\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35;\n\n    this.options = options;\n    this.actionMapping = {\n      mouse: {\n        click: (_d = (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.actionMapping) === null || _b === void 0 ? void 0 : _b.mouse) === null || _c === void 0 ? void 0 : _c.click) !== null && _d !== void 0 ? _d : defaultActionMapping.mouse.click,\n        dblClick: (_h = (_g = (_f = (_e = this.options) === null || _e === void 0 ? void 0 : _e.actionMapping) === null || _f === void 0 ? void 0 : _f.mouse) === null || _g === void 0 ? void 0 : _g.dblClick) !== null && _h !== void 0 ? _h : defaultActionMapping.mouse.dblClick,\n        contextMenu: (_m = (_l = (_k = (_j = this.options) === null || _j === void 0 ? void 0 : _j.actionMapping) === null || _k === void 0 ? void 0 : _k.mouse) === null || _l === void 0 ? void 0 : _l.contextMenu) !== null && _m !== void 0 ? _m : defaultActionMapping.mouse.contextMenu,\n        expanderClick: (_r = (_q = (_p = (_o = this.options) === null || _o === void 0 ? void 0 : _o.actionMapping) === null || _p === void 0 ? void 0 : _p.mouse) === null || _q === void 0 ? void 0 : _q.expanderClick) !== null && _r !== void 0 ? _r : defaultActionMapping.mouse.expanderClick,\n        checkboxClick: (_v = (_u = (_t = (_s = this.options) === null || _s === void 0 ? void 0 : _s.actionMapping) === null || _t === void 0 ? void 0 : _t.mouse) === null || _u === void 0 ? void 0 : _u.checkboxClick) !== null && _v !== void 0 ? _v : defaultActionMapping.mouse.checkboxClick,\n        drop: (_z = (_y = (_x = (_w = this.options) === null || _w === void 0 ? void 0 : _w.actionMapping) === null || _x === void 0 ? void 0 : _x.mouse) === null || _y === void 0 ? void 0 : _y.drop) !== null && _z !== void 0 ? _z : defaultActionMapping.mouse.drop,\n        dragStart: (_3 = (_2 = (_1 = (_0 = this.options) === null || _0 === void 0 ? void 0 : _0.actionMapping) === null || _1 === void 0 ? void 0 : _1.mouse) === null || _2 === void 0 ? void 0 : _2.dragStart) !== null && _3 !== void 0 ? _3 : undefined,\n        drag: (_7 = (_6 = (_5 = (_4 = this.options) === null || _4 === void 0 ? void 0 : _4.actionMapping) === null || _5 === void 0 ? void 0 : _5.mouse) === null || _6 === void 0 ? void 0 : _6.drag) !== null && _7 !== void 0 ? _7 : undefined,\n        dragEnd: (_11 = (_10 = (_9 = (_8 = this.options) === null || _8 === void 0 ? void 0 : _8.actionMapping) === null || _9 === void 0 ? void 0 : _9.mouse) === null || _10 === void 0 ? void 0 : _10.dragEnd) !== null && _11 !== void 0 ? _11 : undefined,\n        dragOver: (_15 = (_14 = (_13 = (_12 = this.options) === null || _12 === void 0 ? void 0 : _12.actionMapping) === null || _13 === void 0 ? void 0 : _13.mouse) === null || _14 === void 0 ? void 0 : _14.dragOver) !== null && _15 !== void 0 ? _15 : undefined,\n        dragLeave: (_19 = (_18 = (_17 = (_16 = this.options) === null || _16 === void 0 ? void 0 : _16.actionMapping) === null || _17 === void 0 ? void 0 : _17.mouse) === null || _18 === void 0 ? void 0 : _18.dragLeave) !== null && _19 !== void 0 ? _19 : undefined,\n        dragEnter: (_23 = (_22 = (_21 = (_20 = this.options) === null || _20 === void 0 ? void 0 : _20.actionMapping) === null || _21 === void 0 ? void 0 : _21.mouse) === null || _22 === void 0 ? void 0 : _22.dragEnter) !== null && _23 !== void 0 ? _23 : undefined,\n        mouseOver: (_27 = (_26 = (_25 = (_24 = this.options) === null || _24 === void 0 ? void 0 : _24.actionMapping) === null || _25 === void 0 ? void 0 : _25.mouse) === null || _26 === void 0 ? void 0 : _26.mouseOver) !== null && _27 !== void 0 ? _27 : undefined,\n        mouseOut: (_31 = (_30 = (_29 = (_28 = this.options) === null || _28 === void 0 ? void 0 : _28.actionMapping) === null || _29 === void 0 ? void 0 : _29.mouse) === null || _30 === void 0 ? void 0 : _30.mouseOut) !== null && _31 !== void 0 ? _31 : undefined\n      },\n      keys: (_keys2 = {}, _defineProperty(_keys2, KEYS.RIGHT, TREE_ACTIONS.DRILL_DOWN), _defineProperty(_keys2, KEYS.LEFT, TREE_ACTIONS.DRILL_UP), _defineProperty(_keys2, KEYS.DOWN, TREE_ACTIONS.NEXT_NODE), _defineProperty(_keys2, KEYS.UP, TREE_ACTIONS.PREVIOUS_NODE), _defineProperty(_keys2, KEYS.SPACE, TREE_ACTIONS.TOGGLE_ACTIVE), _defineProperty(_keys2, KEYS.ENTER, TREE_ACTIONS.TOGGLE_ACTIVE), _keys2)\n    };\n\n    if ((_33 = (_32 = this.options) === null || _32 === void 0 ? void 0 : _32.actionMapping) === null || _33 === void 0 ? void 0 : _33.keys) {\n      this.actionMapping.keys = Object.assign(Object.assign({}, this.actionMapping.keys), this.options.actionMapping.keys);\n    }\n\n    if (options.rtl) {\n      this.actionMapping.keys[KEYS.RIGHT] = ((_34 = options.actionMapping) === null || _34 === void 0 ? void 0 : _34.keys[KEYS.RIGHT]) || TREE_ACTIONS.DRILL_UP;\n      this.actionMapping.keys[KEYS.LEFT] = ((_35 = options.actionMapping) === null || _35 === void 0 ? void 0 : _35.keys[KEYS.LEFT]) || TREE_ACTIONS.DRILL_DOWN;\n    }\n  }\n\n  _createClass(TreeOptions, [{\n    key: \"hasChildrenField\",\n    get: function get() {\n      return this.options.hasChildrenField || 'hasChildren';\n    }\n  }, {\n    key: \"childrenField\",\n    get: function get() {\n      return this.options.childrenField || 'children';\n    }\n  }, {\n    key: \"displayField\",\n    get: function get() {\n      return this.options.displayField || 'name';\n    }\n  }, {\n    key: \"idField\",\n    get: function get() {\n      return this.options.idField || 'id';\n    }\n  }, {\n    key: \"isExpandedField\",\n    get: function get() {\n      return this.options.isExpandedField || 'isExpanded';\n    }\n  }, {\n    key: \"getChildren\",\n    get: function get() {\n      return this.options.getChildren;\n    }\n  }, {\n    key: \"levelPadding\",\n    get: function get() {\n      return this.options.levelPadding || 0;\n    }\n  }, {\n    key: \"useVirtualScroll\",\n    get: function get() {\n      return this.options.useVirtualScroll;\n    }\n  }, {\n    key: \"animateExpand\",\n    get: function get() {\n      return this.options.animateExpand;\n    }\n  }, {\n    key: \"animateSpeed\",\n    get: function get() {\n      return this.options.animateSpeed || 1;\n    }\n  }, {\n    key: \"animateAcceleration\",\n    get: function get() {\n      return this.options.animateAcceleration || 1.2;\n    }\n  }, {\n    key: \"scrollOnActivate\",\n    get: function get() {\n      return this.options.scrollOnActivate === undefined ? true : this.options.scrollOnActivate;\n    }\n  }, {\n    key: \"rtl\",\n    get: function get() {\n      return !!this.options.rtl;\n    }\n  }, {\n    key: \"rootId\",\n    get: function get() {\n      return this.options.rootId;\n    }\n  }, {\n    key: \"useCheckbox\",\n    get: function get() {\n      return this.options.useCheckbox;\n    }\n  }, {\n    key: \"useTriState\",\n    get: function get() {\n      return this.options.useTriState === undefined ? true : this.options.useTriState;\n    }\n  }, {\n    key: \"scrollContainer\",\n    get: function get() {\n      return this.options.scrollContainer;\n    }\n  }, {\n    key: \"allowDragoverStyling\",\n    get: function get() {\n      return this.options.allowDragoverStyling === undefined ? true : this.options.allowDragoverStyling;\n    }\n  }, {\n    key: \"getNodeClone\",\n    value: function getNodeClone(node) {\n      if (this.options.getNodeClone) {\n        return this.options.getNodeClone(node);\n      } // remove id from clone\n      // keeping ie11 compatibility\n\n\n      var nodeClone = Object.assign({}, node.data);\n\n      if (nodeClone.id) {\n        delete nodeClone.id;\n      }\n\n      return nodeClone;\n    }\n  }, {\n    key: \"allowDrop\",\n    value: function allowDrop(element, to, $event) {\n      if (this.options.allowDrop instanceof Function) {\n        return this.options.allowDrop(element, to, $event);\n      } else {\n        return this.options.allowDrop === undefined ? true : this.options.allowDrop;\n      }\n    }\n  }, {\n    key: \"allowDrag\",\n    value: function allowDrag(node) {\n      if (this.options.allowDrag instanceof Function) {\n        return this.options.allowDrag(node);\n      } else {\n        return this.options.allowDrag;\n      }\n    }\n  }, {\n    key: \"nodeClass\",\n    value: function nodeClass(node) {\n      return this.options.nodeClass ? this.options.nodeClass(node) : '';\n    }\n  }, {\n    key: \"nodeHeight\",\n    value: function nodeHeight(node) {\n      if (node.data.virtual) {\n        return 0;\n      }\n\n      var nodeHeight = this.options.nodeHeight || 22;\n\n      if (typeof nodeHeight === 'function') {\n        nodeHeight = nodeHeight(node);\n      } // account for drop slots:\n\n\n      return nodeHeight + (node.index === 0 ? 2 : 1) * this.dropSlotHeight;\n    }\n  }, {\n    key: \"dropSlotHeight\",\n    get: function get() {\n      return typeof this.options.dropSlotHeight === 'number' ? this.options.dropSlotHeight : 2;\n    }\n  }]);\n\n  return TreeOptions;\n}();\n\nvar TREE_EVENTS = {\n  toggleExpanded: 'toggleExpanded',\n  activate: 'activate',\n  deactivate: 'deactivate',\n  nodeActivate: 'nodeActivate',\n  nodeDeactivate: 'nodeDeactivate',\n  select: 'select',\n  deselect: 'deselect',\n  focus: 'focus',\n  blur: 'blur',\n  initialized: 'initialized',\n  updateData: 'updateData',\n  moveNode: 'moveNode',\n  copyNode: 'copyNode',\n  event: 'event',\n  loadNodeChildren: 'loadNodeChildren',\n  changeFilter: 'changeFilter',\n  stateChange: 'stateChange'\n};\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar TreeNode = /*@__PURE__*/function () {\n  var TreeNode = /*#__PURE__*/function () {\n    function TreeNode(data, parent, treeModel, index) {\n      var _this = this;\n\n      _classCallCheck(this, TreeNode);\n\n      this.data = data;\n      this.parent = parent;\n      this.treeModel = treeModel;\n      this.position = 0;\n\n      this.allowDrop = function (element, $event) {\n        return _this.options.allowDrop(element, {\n          parent: _this,\n          index: 0\n        }, $event);\n      };\n\n      this.allowDragoverStyling = function () {\n        return _this.options.allowDragoverStyling;\n      };\n\n      if (this.id === undefined || this.id === null) {\n        this.id = uuid();\n      } // Make sure there's a unique id without overriding existing ids to work with immutable data structures\n\n\n      this.index = index;\n\n      if (this.getField('children')) {\n        this._initChildren();\n      }\n\n      this.autoLoadChildren();\n    }\n\n    _createClass(TreeNode, [{\n      key: \"isHidden\",\n      get: function get() {\n        return this.treeModel.isHidden(this);\n      }\n    }, {\n      key: \"isExpanded\",\n      get: function get() {\n        return this.treeModel.isExpanded(this);\n      }\n    }, {\n      key: \"isActive\",\n      get: function get() {\n        return this.treeModel.isActive(this);\n      }\n    }, {\n      key: \"isFocused\",\n      get: function get() {\n        return this.treeModel.isNodeFocused(this);\n      }\n    }, {\n      key: \"isSelected\",\n      get: function get() {\n        if (this.isSelectable()) {\n          return this.treeModel.isSelected(this);\n        } else {\n          return this.children.some(function (node) {\n            return node.isSelected;\n          });\n        }\n      }\n    }, {\n      key: \"isAllSelected\",\n      get: function get() {\n        if (this.isSelectable()) {\n          return this.treeModel.isSelected(this);\n        } else {\n          return this.children.every(function (node) {\n            return node.isAllSelected;\n          });\n        }\n      }\n    }, {\n      key: \"isPartiallySelected\",\n      get: function get() {\n        return this.isSelected && !this.isAllSelected;\n      }\n    }, {\n      key: \"level\",\n      get: function get() {\n        return this.parent ? this.parent.level + 1 : 0;\n      }\n    }, {\n      key: \"path\",\n      get: function get() {\n        return this.parent ? [].concat(_toConsumableArray(this.parent.path), [this.id]) : [];\n      }\n    }, {\n      key: \"elementRef\",\n      get: function get() {\n        throw \"Element Ref is no longer supported since introducing virtual scroll\\n\\n      You may use a template to obtain a reference to the element\";\n      }\n    }, {\n      key: \"originalNode\",\n      get: function get() {\n        return this._originalNode;\n      }\n    }, {\n      key: \"hasChildren\",\n      get: // helper get functions:\n      function get() {\n        return !!(this.getField('hasChildren') || this.children && this.children.length > 0);\n      }\n    }, {\n      key: \"isCollapsed\",\n      get: function get() {\n        return !this.isExpanded;\n      }\n    }, {\n      key: \"isLeaf\",\n      get: function get() {\n        return !this.hasChildren;\n      }\n    }, {\n      key: \"isRoot\",\n      get: function get() {\n        return this.parent.data.virtual;\n      }\n    }, {\n      key: \"realParent\",\n      get: function get() {\n        return this.isRoot ? null : this.parent;\n      } // proxy functions:\n\n    }, {\n      key: \"options\",\n      get: function get() {\n        return this.treeModel.options;\n      }\n    }, {\n      key: \"fireEvent\",\n      value: function fireEvent(event) {\n        this.treeModel.fireEvent(event);\n      } // field accessors:\n\n    }, {\n      key: \"displayField\",\n      get: function get() {\n        return this.getField('display');\n      }\n    }, {\n      key: \"id\",\n      get: function get() {\n        return this.getField('id');\n      },\n      set: function set(value) {\n        this.setField('id', value);\n      }\n    }, {\n      key: \"getField\",\n      value: function getField(key) {\n        return this.data[this.options[\"\".concat(key, \"Field\")]];\n      }\n    }, {\n      key: \"setField\",\n      value: function setField(key, value) {\n        this.data[this.options[\"\".concat(key, \"Field\")]] = value;\n      } // traversing:\n\n    }, {\n      key: \"_findAdjacentSibling\",\n      value: function _findAdjacentSibling(steps) {\n        var skipHidden = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        var siblings = this._getParentsChildren(skipHidden);\n\n        var index = siblings.indexOf(this);\n        return siblings.length > index + steps ? siblings[index + steps] : null;\n      }\n    }, {\n      key: \"findNextSibling\",\n      value: function findNextSibling() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        return this._findAdjacentSibling(+1, skipHidden);\n      }\n    }, {\n      key: \"findPreviousSibling\",\n      value: function findPreviousSibling() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        return this._findAdjacentSibling(-1, skipHidden);\n      }\n    }, {\n      key: \"getVisibleChildren\",\n      value: function getVisibleChildren() {\n        return this.visibleChildren;\n      }\n    }, {\n      key: \"visibleChildren\",\n      get: function get() {\n        return (this.children || []).filter(function (node) {\n          return !node.isHidden;\n        });\n      }\n    }, {\n      key: \"getFirstChild\",\n      value: function getFirstChild() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var children = skipHidden ? this.visibleChildren : this.children;\n        return children != null && children.length ? children[0] : null;\n      }\n    }, {\n      key: \"getLastChild\",\n      value: function getLastChild() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var children = skipHidden ? this.visibleChildren : this.children;\n        return children != null && children.length ? children[children.length - 1] : null;\n      }\n    }, {\n      key: \"findNextNode\",\n      value: function findNextNode() {\n        var goInside = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var skipHidden = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        return goInside && this.isExpanded && this.getFirstChild(skipHidden) || this.findNextSibling(skipHidden) || this.parent && this.parent.findNextNode(false, skipHidden);\n      }\n    }, {\n      key: \"findPreviousNode\",\n      value: function findPreviousNode() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var previousSibling = this.findPreviousSibling(skipHidden);\n\n        if (!previousSibling) {\n          return this.realParent;\n        }\n\n        return previousSibling._getLastOpenDescendant(skipHidden);\n      }\n    }, {\n      key: \"_getLastOpenDescendant\",\n      value: function _getLastOpenDescendant() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var lastChild = this.getLastChild(skipHidden);\n        return this.isCollapsed || !lastChild ? this : lastChild._getLastOpenDescendant(skipHidden);\n      }\n    }, {\n      key: \"_getParentsChildren\",\n      value: function _getParentsChildren() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var children = this.parent && (skipHidden ? this.parent.getVisibleChildren() : this.parent.children);\n        return children || [];\n      }\n    }, {\n      key: \"getIndexInParent\",\n      value: function getIndexInParent() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        return this._getParentsChildren(skipHidden).indexOf(this);\n      }\n    }, {\n      key: \"isDescendantOf\",\n      value: function isDescendantOf(node) {\n        if (this === node) return true;else return this.parent && this.parent.isDescendantOf(node);\n      }\n    }, {\n      key: \"getNodePadding\",\n      value: function getNodePadding() {\n        return this.options.levelPadding * (this.level - 1) + 'px';\n      }\n    }, {\n      key: \"getClass\",\n      value: function getClass() {\n        return [this.options.nodeClass(this), \"tree-node-level-\".concat(this.level)].join(' ');\n      }\n    }, {\n      key: \"onDrop\",\n      value: function onDrop($event) {\n        this.mouseAction('drop', $event.event, {\n          from: $event.element,\n          to: {\n            parent: this,\n            index: 0,\n            dropOnNode: true\n          }\n        });\n      }\n    }, {\n      key: \"allowDrag\",\n      value: function allowDrag() {\n        return this.options.allowDrag(this);\n      } // helper methods:\n\n    }, {\n      key: \"loadNodeChildren\",\n      value: function loadNodeChildren() {\n        var _this2 = this;\n\n        if (!this.options.getChildren) {\n          return Promise.resolve(); // Not getChildren method - for using redux\n        }\n\n        return Promise.resolve(this.options.getChildren(this)).then(function (children) {\n          if (children) {\n            _this2.setField('children', children);\n\n            _this2._initChildren();\n\n            if (_this2.options.useTriState && _this2.treeModel.isSelected(_this2)) {\n              _this2.setIsSelected(true);\n            }\n\n            _this2.children.forEach(function (child) {\n              if (child.getField('isExpanded') && child.hasChildren) {\n                child.expand();\n              }\n            });\n          }\n        }).then(function () {\n          _this2.fireEvent({\n            eventName: TREE_EVENTS.loadNodeChildren,\n            node: _this2\n          });\n        });\n      }\n    }, {\n      key: \"expand\",\n      value: function expand() {\n        if (!this.isExpanded) {\n          this.toggleExpanded();\n        }\n\n        return this;\n      }\n    }, {\n      key: \"collapse\",\n      value: function collapse() {\n        if (this.isExpanded) {\n          this.toggleExpanded();\n        }\n\n        return this;\n      }\n    }, {\n      key: \"doForAll\",\n      value: function doForAll(fn) {\n        var _this3 = this;\n\n        Promise.resolve(fn(this)).then(function () {\n          if (_this3.children) {\n            _this3.children.forEach(function (child) {\n              return child.doForAll(fn);\n            });\n          }\n        });\n      }\n    }, {\n      key: \"expandAll\",\n      value: function expandAll() {\n        this.doForAll(function (node) {\n          return node.expand();\n        });\n      }\n    }, {\n      key: \"collapseAll\",\n      value: function collapseAll() {\n        this.doForAll(function (node) {\n          return node.collapse();\n        });\n      }\n    }, {\n      key: \"ensureVisible\",\n      value: function ensureVisible() {\n        if (this.realParent) {\n          this.realParent.expand();\n          this.realParent.ensureVisible();\n        }\n\n        return this;\n      }\n    }, {\n      key: \"toggleExpanded\",\n      value: function toggleExpanded() {\n        this.setIsExpanded(!this.isExpanded);\n        return this;\n      }\n    }, {\n      key: \"setIsExpanded\",\n      value: function setIsExpanded(value) {\n        if (this.hasChildren) {\n          this.treeModel.setExpandedNode(this, value);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"autoLoadChildren\",\n      value: function autoLoadChildren() {\n        var _this4 = this;\n\n        this.handler = reaction(function () {\n          return _this4.isExpanded;\n        }, function (isExpanded) {\n          if (!_this4.children && _this4.hasChildren && isExpanded) {\n            _this4.loadNodeChildren();\n          }\n        }, {\n          fireImmediately: true\n        });\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this.children) {\n          this.children.forEach(function (child) {\n            return child.dispose();\n          });\n        }\n\n        if (this.handler) {\n          this.handler();\n        }\n\n        this.parent = null;\n        this.children = null;\n      }\n    }, {\n      key: \"setIsActive\",\n      value: function setIsActive(value) {\n        var multi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        this.treeModel.setActiveNode(this, value, multi);\n\n        if (value) {\n          this.focus(this.options.scrollOnActivate);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"isSelectable\",\n      value: function isSelectable() {\n        return this.isLeaf || !this.children || !this.options.useTriState;\n      }\n    }, {\n      key: \"setIsSelected\",\n      value: function setIsSelected(value) {\n        if (this.isSelectable()) {\n          this.treeModel.setSelectedNode(this, value);\n        } else {\n          this.visibleChildren.forEach(function (child) {\n            return child.setIsSelected(value);\n          });\n        }\n\n        return this;\n      }\n    }, {\n      key: \"toggleSelected\",\n      value: function toggleSelected() {\n        this.setIsSelected(!this.isSelected);\n        return this;\n      }\n    }, {\n      key: \"toggleActivated\",\n      value: function toggleActivated() {\n        var multi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        this.setIsActive(!this.isActive, multi);\n        return this;\n      }\n    }, {\n      key: \"setActiveAndVisible\",\n      value: function setActiveAndVisible() {\n        var multi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        this.setIsActive(true, multi).ensureVisible();\n        setTimeout(this.scrollIntoView.bind(this));\n        return this;\n      }\n    }, {\n      key: \"scrollIntoView\",\n      value: function scrollIntoView() {\n        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        this.treeModel.virtualScroll.scrollIntoView(this, force);\n      }\n    }, {\n      key: \"focus\",\n      value: function focus() {\n        var scroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var previousNode = this.treeModel.getFocusedNode();\n        this.treeModel.setFocusedNode(this);\n\n        if (scroll) {\n          this.scrollIntoView();\n        }\n\n        if (previousNode) {\n          this.fireEvent({\n            eventName: TREE_EVENTS.blur,\n            node: previousNode\n          });\n        }\n\n        this.fireEvent({\n          eventName: TREE_EVENTS.focus,\n          node: this\n        });\n        return this;\n      }\n    }, {\n      key: \"blur\",\n      value: function blur() {\n        var previousNode = this.treeModel.getFocusedNode();\n        this.treeModel.setFocusedNode(null);\n\n        if (previousNode) {\n          this.fireEvent({\n            eventName: TREE_EVENTS.blur,\n            node: this\n          });\n        }\n\n        return this;\n      }\n    }, {\n      key: \"setIsHidden\",\n      value: function setIsHidden(value) {\n        this.treeModel.setIsHidden(this, value);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.setIsHidden(true);\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        this.setIsHidden(false);\n      }\n    }, {\n      key: \"mouseAction\",\n      value: function mouseAction(actionName, $event) {\n        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        this.treeModel.setFocus(true);\n        var actionMapping = this.options.actionMapping.mouse;\n        var mouseAction = actionMapping[actionName];\n\n        if (mouseAction) {\n          mouseAction(this.treeModel, this, $event, data);\n        }\n      }\n    }, {\n      key: \"getSelfHeight\",\n      value: function getSelfHeight() {\n        return this.options.nodeHeight(this);\n      }\n    }, {\n      key: \"_initChildren\",\n      value: function _initChildren() {\n        var _this5 = this;\n\n        this.children = this.getField('children').map(function (c, index) {\n          return new TreeNode(c, _this5, _this5.treeModel, index);\n        });\n      }\n    }]);\n\n    return TreeNode;\n  }();\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isHidden\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isExpanded\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isActive\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isFocused\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isSelected\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isAllSelected\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"isPartiallySelected\", null);\n\n  __decorate([observable$1, __metadata(\"design:type\", Array)], TreeNode.prototype, \"children\", void 0);\n\n  __decorate([observable$1, __metadata(\"design:type\", Number)], TreeNode.prototype, \"index\", void 0);\n\n  __decorate([observable$1, __metadata(\"design:type\", Object)], TreeNode.prototype, \"position\", void 0);\n\n  __decorate([observable$1, __metadata(\"design:type\", Number)], TreeNode.prototype, \"height\", void 0);\n\n  __decorate([computed$1, __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"level\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"path\", null);\n\n  __decorate([computed$1, __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [])], TreeNode.prototype, \"visibleChildren\", null);\n\n  __decorate([action$1, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], TreeNode.prototype, \"setIsSelected\", null);\n\n  __decorate([action$1, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], TreeNode.prototype, \"_initChildren\", null);\n\n  return TreeNode;\n}();\n\nfunction uuid() {\n  return Math.floor(Math.random() * 10000000000000);\n}\n\nvar __decorate$1 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata$1 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar TreeModel = /*@__PURE__*/function () {\n  var TreeModel = /*#__PURE__*/function () {\n    function TreeModel() {\n      _classCallCheck(this, TreeModel);\n\n      this.options = new TreeOptions();\n      this.eventNames = Object.keys(TREE_EVENTS);\n      this.expandedNodeIds = {};\n      this.selectedLeafNodeIds = {};\n      this.activeNodeIds = {};\n      this.hiddenNodeIds = {};\n      this.focusedNodeId = null;\n      this.firstUpdate = true;\n      this.subscriptions = [];\n    } // events\n\n\n    _createClass(TreeModel, [{\n      key: \"fireEvent\",\n      value: function fireEvent(event) {\n        event.treeModel = this;\n        this.events[event.eventName].emit(event);\n        this.events.event.emit(event);\n      }\n    }, {\n      key: \"subscribe\",\n      value: function subscribe(eventName, fn) {\n        var subscription = this.events[eventName].subscribe(fn);\n        this.subscriptions.push(subscription);\n      } // getters\n\n    }, {\n      key: \"getFocusedNode\",\n      value: function getFocusedNode() {\n        return this.focusedNode;\n      }\n    }, {\n      key: \"getActiveNode\",\n      value: function getActiveNode() {\n        return this.activeNodes[0];\n      }\n    }, {\n      key: \"getActiveNodes\",\n      value: function getActiveNodes() {\n        return this.activeNodes;\n      }\n    }, {\n      key: \"getVisibleRoots\",\n      value: function getVisibleRoots() {\n        return this.virtualRoot.visibleChildren;\n      }\n    }, {\n      key: \"getFirstRoot\",\n      value: function getFirstRoot() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var root = skipHidden ? this.getVisibleRoots() : this.roots;\n        return root != null && root.length ? root[0] : null;\n      }\n    }, {\n      key: \"getLastRoot\",\n      value: function getLastRoot() {\n        var skipHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var root = skipHidden ? this.getVisibleRoots() : this.roots;\n        return root != null && root.length ? root[root.length - 1] : null;\n      }\n    }, {\n      key: \"isFocused\",\n      get: function get() {\n        return TreeModel.focusedTree === this;\n      }\n    }, {\n      key: \"isNodeFocused\",\n      value: function isNodeFocused(node) {\n        return this.focusedNode === node;\n      }\n    }, {\n      key: \"isEmptyTree\",\n      value: function isEmptyTree() {\n        return this.roots && this.roots.length === 0;\n      }\n    }, {\n      key: \"focusedNode\",\n      get: function get() {\n        return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;\n      }\n    }, {\n      key: \"expandedNodes\",\n      get: function get() {\n        var _this6 = this;\n\n        var nodes = Object.keys(this.expandedNodeIds).filter(function (id) {\n          return _this6.expandedNodeIds[id];\n        }).map(function (id) {\n          return _this6.getNodeById(id);\n        });\n        return nodes.filter(Boolean);\n      }\n    }, {\n      key: \"activeNodes\",\n      get: function get() {\n        var _this7 = this;\n\n        var nodes = Object.keys(this.activeNodeIds).filter(function (id) {\n          return _this7.activeNodeIds[id];\n        }).map(function (id) {\n          return _this7.getNodeById(id);\n        });\n        return nodes.filter(Boolean);\n      }\n    }, {\n      key: \"hiddenNodes\",\n      get: function get() {\n        var _this8 = this;\n\n        var nodes = Object.keys(this.hiddenNodeIds).filter(function (id) {\n          return _this8.hiddenNodeIds[id];\n        }).map(function (id) {\n          return _this8.getNodeById(id);\n        });\n        return nodes.filter(Boolean);\n      }\n    }, {\n      key: \"selectedLeafNodes\",\n      get: function get() {\n        var _this9 = this;\n\n        var nodes = Object.keys(this.selectedLeafNodeIds).filter(function (id) {\n          return _this9.selectedLeafNodeIds[id];\n        }).map(function (id) {\n          return _this9.getNodeById(id);\n        });\n        return nodes.filter(Boolean);\n      } // locating nodes\n\n    }, {\n      key: \"getNodeByPath\",\n      value: function getNodeByPath(path) {\n        var startNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        if (!path) return null;\n        startNode = startNode || this.virtualRoot;\n        if (path.length === 0) return startNode;\n        if (!startNode.children) return null;\n        var childId = path.shift();\n        var childNode = startNode.children.find(function (c) {\n          return c.id === childId;\n        });\n        if (!childNode) return null;\n        return this.getNodeByPath(path, childNode);\n      }\n    }, {\n      key: \"getNodeById\",\n      value: function getNodeById(id) {\n        var idStr = id.toString();\n        return this.getNodeBy(function (node) {\n          return node.id.toString() === idStr;\n        });\n      }\n    }, {\n      key: \"getNodeBy\",\n      value: function getNodeBy(predicate) {\n        var startNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        startNode = startNode || this.virtualRoot;\n        if (!startNode.children) return null;\n        var found = startNode.children.find(predicate);\n\n        if (found) {\n          // found in children\n          return found;\n        } else {\n          // look in children's children\n          var _iterator = _createForOfIteratorHelper(startNode.children),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var child = _step.value;\n              var foundInChildren = this.getNodeBy(predicate, child);\n              if (foundInChildren) return foundInChildren;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n    }, {\n      key: \"isExpanded\",\n      value: function isExpanded(node) {\n        return this.expandedNodeIds[node.id];\n      }\n    }, {\n      key: \"isHidden\",\n      value: function isHidden(node) {\n        return this.hiddenNodeIds[node.id];\n      }\n    }, {\n      key: \"isActive\",\n      value: function isActive(node) {\n        return this.activeNodeIds[node.id];\n      }\n    }, {\n      key: \"isSelected\",\n      value: function isSelected(node) {\n        return this.selectedLeafNodeIds[node.id];\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.dispose();\n        this.unsubscribeAll();\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        // Dispose reactions of the replaced nodes\n        if (this.virtualRoot) {\n          this.virtualRoot.dispose();\n        }\n      }\n    }, {\n      key: \"unsubscribeAll\",\n      value: function unsubscribeAll() {\n        this.subscriptions.forEach(function (subscription) {\n          return subscription.unsubscribe();\n        });\n        this.subscriptions = [];\n      } // actions\n\n    }, {\n      key: \"setData\",\n      value: function setData(_ref2) {\n        var nodes = _ref2.nodes,\n            _ref2$options = _ref2.options,\n            options = _ref2$options === void 0 ? null : _ref2$options,\n            _ref2$events = _ref2.events,\n            events = _ref2$events === void 0 ? null : _ref2$events;\n\n        if (options) {\n          this.options = new TreeOptions(options);\n        }\n\n        if (events) {\n          this.events = events;\n        }\n\n        if (nodes) {\n          this.nodes = nodes;\n        }\n\n        this.update();\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        // Rebuild tree:\n        var virtualRootConfig = _defineProperty({\n          id: this.options.rootId,\n          virtual: true\n        }, this.options.childrenField, this.nodes);\n\n        this.dispose();\n        this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);\n        this.roots = this.virtualRoot.children; // Fire event:\n\n        if (this.firstUpdate) {\n          if (this.roots) {\n            this.firstUpdate = false;\n\n            this._calculateExpandedNodes();\n          }\n        } else {\n          this.fireEvent({\n            eventName: TREE_EVENTS.updateData\n          });\n        }\n      }\n    }, {\n      key: \"setFocusedNode\",\n      value: function setFocusedNode(node) {\n        this.focusedNodeId = node ? node.id : null;\n      }\n    }, {\n      key: \"setFocus\",\n      value: function setFocus(value) {\n        TreeModel.focusedTree = value ? this : null;\n      }\n    }, {\n      key: \"doForAll\",\n      value: function doForAll(fn) {\n        this.roots.forEach(function (root) {\n          return root.doForAll(fn);\n        });\n      }\n    }, {\n      key: \"focusNextNode\",\n      value: function focusNextNode() {\n        var previousNode = this.getFocusedNode();\n        var nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);\n        if (nextNode) nextNode.focus();\n      }\n    }, {\n      key: \"focusPreviousNode\",\n      value: function focusPreviousNode() {\n        var previousNode = this.getFocusedNode();\n        var nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);\n        if (nextNode) nextNode.focus();\n      }\n    }, {\n      key: \"focusDrillDown\",\n      value: function focusDrillDown() {\n        var previousNode = this.getFocusedNode();\n\n        if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {\n          previousNode.toggleExpanded();\n        } else {\n          var nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);\n          if (nextNode) nextNode.focus();\n        }\n      }\n    }, {\n      key: \"focusDrillUp\",\n      value: function focusDrillUp() {\n        var previousNode = this.getFocusedNode();\n        if (!previousNode) return;\n\n        if (previousNode.isExpanded) {\n          previousNode.toggleExpanded();\n        } else {\n          var nextNode = previousNode.realParent;\n          if (nextNode) nextNode.focus();\n        }\n      }\n    }, {\n      key: \"setActiveNode\",\n      value: function setActiveNode(node, value) {\n        var multi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (multi) {\n          this._setActiveNodeMulti(node, value);\n        } else {\n          this._setActiveNodeSingle(node, value);\n        }\n\n        if (value) {\n          node.focus(this.options.scrollOnActivate);\n          this.fireEvent({\n            eventName: TREE_EVENTS.activate,\n            node: node\n          });\n          this.fireEvent({\n            eventName: TREE_EVENTS.nodeActivate,\n            node: node\n          }); // For IE11\n        } else {\n          this.fireEvent({\n            eventName: TREE_EVENTS.deactivate,\n            node: node\n          });\n          this.fireEvent({\n            eventName: TREE_EVENTS.nodeDeactivate,\n            node: node\n          }); // For IE11\n        }\n      }\n    }, {\n      key: \"setSelectedNode\",\n      value: function setSelectedNode(node, value) {\n        this.selectedLeafNodeIds = Object.assign({}, this.selectedLeafNodeIds, _defineProperty({}, node.id, value));\n\n        if (value) {\n          node.focus();\n          this.fireEvent({\n            eventName: TREE_EVENTS.select,\n            node: node\n          });\n        } else {\n          this.fireEvent({\n            eventName: TREE_EVENTS.deselect,\n            node: node\n          });\n        }\n      }\n    }, {\n      key: \"setExpandedNode\",\n      value: function setExpandedNode(node, value) {\n        this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, _defineProperty({}, node.id, value));\n        this.fireEvent({\n          eventName: TREE_EVENTS.toggleExpanded,\n          node: node,\n          isExpanded: value\n        });\n      }\n    }, {\n      key: \"expandAll\",\n      value: function expandAll() {\n        this.roots.forEach(function (root) {\n          return root.expandAll();\n        });\n      }\n    }, {\n      key: \"collapseAll\",\n      value: function collapseAll() {\n        this.roots.forEach(function (root) {\n          return root.collapseAll();\n        });\n      }\n    }, {\n      key: \"setIsHidden\",\n      value: function setIsHidden(node, value) {\n        this.hiddenNodeIds = Object.assign({}, this.hiddenNodeIds, _defineProperty({}, node.id, value));\n      }\n    }, {\n      key: \"setHiddenNodeIds\",\n      value: function setHiddenNodeIds(nodeIds) {\n        this.hiddenNodeIds = nodeIds.reduce(function (hiddenNodeIds, id) {\n          return Object.assign(hiddenNodeIds, _defineProperty({}, id, true));\n        }, {});\n      }\n    }, {\n      key: \"performKeyAction\",\n      value: function performKeyAction(node, $event) {\n        var keyAction = this.options.actionMapping.keys[$event.keyCode];\n\n        if (keyAction) {\n          $event.preventDefault();\n          keyAction(this, node, $event);\n          return true;\n        } else {\n          return false;\n        }\n      }\n    }, {\n      key: \"filterNodes\",\n      value: function filterNodes(filter) {\n        var _this10 = this;\n\n        var autoShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var filterFn;\n\n        if (!filter) {\n          return this.clearFilter();\n        } // support function and string filter\n\n\n        if (filter && typeof filter.valueOf() === 'string') {\n          filterFn = function filterFn(node) {\n            return node.displayField.toLowerCase().indexOf(filter.toLowerCase()) !== -1;\n          };\n        } else if (filter && typeof filter === 'function') {\n          filterFn = filter;\n        } else {\n          console.error('Don\\'t know what to do with filter', filter);\n          console.error('Should be either a string or function');\n          return;\n        }\n\n        var ids = {};\n        this.roots.forEach(function (node) {\n          return _this10._filterNode(ids, node, filterFn, autoShow);\n        });\n        this.hiddenNodeIds = ids;\n        this.fireEvent({\n          eventName: TREE_EVENTS.changeFilter\n        });\n      }\n    }, {\n      key: \"clearFilter\",\n      value: function clearFilter() {\n        this.hiddenNodeIds = {};\n        this.fireEvent({\n          eventName: TREE_EVENTS.changeFilter\n        });\n      }\n    }, {\n      key: \"moveNode\",\n      value: function moveNode(node, to) {\n        var fromIndex = node.getIndexInParent();\n        var fromParent = node.parent;\n        if (!this.canMoveNode(node, to, fromIndex)) return;\n        var fromChildren = fromParent.getField('children'); // If node doesn't have children - create children array\n\n        if (!to.parent.getField('children')) {\n          to.parent.setField('children', []);\n        }\n\n        var toChildren = to.parent.getField('children');\n        var originalNode = fromChildren.splice(fromIndex, 1)[0]; // Compensate for index if already removed from parent:\n\n        var toIndex = fromParent === to.parent && to.index > fromIndex ? to.index - 1 : to.index;\n        toChildren.splice(toIndex, 0, originalNode);\n        fromParent.treeModel.update();\n\n        if (to.parent.treeModel !== fromParent.treeModel) {\n          to.parent.treeModel.update();\n        }\n\n        this.fireEvent({\n          eventName: TREE_EVENTS.moveNode,\n          node: originalNode,\n          to: {\n            parent: to.parent.data,\n            index: toIndex\n          },\n          from: {\n            parent: fromParent.data,\n            index: fromIndex\n          }\n        });\n      }\n    }, {\n      key: \"copyNode\",\n      value: function copyNode(node, to) {\n        var fromIndex = node.getIndexInParent();\n        if (!this.canMoveNode(node, to, fromIndex)) return; // If node doesn't have children - create children array\n\n        if (!to.parent.getField('children')) {\n          to.parent.setField('children', []);\n        }\n\n        var toChildren = to.parent.getField('children');\n        var nodeCopy = this.options.getNodeClone(node);\n        toChildren.splice(to.index, 0, nodeCopy);\n        node.treeModel.update();\n\n        if (to.parent.treeModel !== node.treeModel) {\n          to.parent.treeModel.update();\n        }\n\n        this.fireEvent({\n          eventName: TREE_EVENTS.copyNode,\n          node: nodeCopy,\n          to: {\n            parent: to.parent.data,\n            index: to.index\n          }\n        });\n      }\n    }, {\n      key: \"getState\",\n      value: function getState() {\n        return {\n          expandedNodeIds: this.expandedNodeIds,\n          selectedLeafNodeIds: this.selectedLeafNodeIds,\n          activeNodeIds: this.activeNodeIds,\n          hiddenNodeIds: this.hiddenNodeIds,\n          focusedNodeId: this.focusedNodeId\n        };\n      }\n    }, {\n      key: \"setState\",\n      value: function setState(state) {\n        if (!state) return;\n        Object.assign(this, {\n          expandedNodeIds: state.expandedNodeIds || {},\n          selectedLeafNodeIds: state.selectedLeafNodeIds || {},\n          activeNodeIds: state.activeNodeIds || {},\n          hiddenNodeIds: state.hiddenNodeIds || {},\n          focusedNodeId: state.focusedNodeId\n        });\n      }\n    }, {\n      key: \"subscribeToState\",\n      value: function subscribeToState(fn) {\n        var _this11 = this;\n\n        autorun(function () {\n          return fn(_this11.getState());\n        });\n      }\n    }, {\n      key: \"canMoveNode\",\n      value: function canMoveNode(node, to) {\n        var fromIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n        var fromNodeIndex = fromIndex || node.getIndexInParent(); // same node:\n\n        if (node.parent === to.parent && fromIndex === to.index) {\n          return false;\n        }\n\n        return !to.parent.isDescendantOf(node);\n      }\n    }, {\n      key: \"calculateExpandedNodes\",\n      value: function calculateExpandedNodes() {\n        this._calculateExpandedNodes();\n      } // private methods\n\n    }, {\n      key: \"_filterNode\",\n      value: function _filterNode(ids, node, filterFn, autoShow) {\n        var _this12 = this;\n\n        // if node passes function then it's visible\n        var isVisible = filterFn(node);\n\n        if (node.children) {\n          // if one of node's children passes filter then this node is also visible\n          node.children.forEach(function (child) {\n            if (_this12._filterNode(ids, child, filterFn, autoShow)) {\n              isVisible = true;\n            }\n          });\n        } // mark node as hidden\n\n\n        if (!isVisible) {\n          ids[node.id] = true;\n        } // auto expand parents to make sure the filtered nodes are visible\n\n\n        if (autoShow && isVisible) {\n          node.ensureVisible();\n        }\n\n        return isVisible;\n      }\n    }, {\n      key: \"_calculateExpandedNodes\",\n      value: function _calculateExpandedNodes() {\n        var _this13 = this;\n\n        var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        startNode = startNode || this.virtualRoot;\n\n        if (startNode.data[this.options.isExpandedField]) {\n          this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, _defineProperty({}, startNode.id, true));\n        }\n\n        if (startNode.children) {\n          startNode.children.forEach(function (child) {\n            return _this13._calculateExpandedNodes(child);\n          });\n        }\n      }\n    }, {\n      key: \"_setActiveNodeSingle\",\n      value: function _setActiveNodeSingle(node, value) {\n        var _this14 = this;\n\n        // Deactivate all other nodes:\n        this.activeNodes.filter(function (activeNode) {\n          return activeNode !== node;\n        }).forEach(function (activeNode) {\n          _this14.fireEvent({\n            eventName: TREE_EVENTS.deactivate,\n            node: activeNode\n          });\n\n          _this14.fireEvent({\n            eventName: TREE_EVENTS.nodeDeactivate,\n            node: activeNode\n          }); // For IE11\n\n        });\n\n        if (value) {\n          this.activeNodeIds = _defineProperty({}, node.id, true);\n        } else {\n          this.activeNodeIds = {};\n        }\n      }\n    }, {\n      key: \"_setActiveNodeMulti\",\n      value: function _setActiveNodeMulti(node, value) {\n        this.activeNodeIds = Object.assign({}, this.activeNodeIds, _defineProperty({}, node.id, value));\n      }\n    }]);\n\n    return TreeModel;\n  }();\n\n  TreeModel.ɵfac = function TreeModel_Factory(t) {\n    return new (t || TreeModel)();\n  };\n\n  TreeModel.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TreeModel,\n    factory: TreeModel.ɵfac\n  });\n  TreeModel.focusedTree = null;\n\n  __decorate$1([observable$1, __metadata$1(\"design:type\", Array)], TreeModel.prototype, \"roots\", void 0);\n\n  __decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"expandedNodeIds\", void 0);\n\n  __decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"selectedLeafNodeIds\", void 0);\n\n  __decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"activeNodeIds\", void 0);\n\n  __decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"hiddenNodeIds\", void 0);\n\n  __decorate$1([observable$1, __metadata$1(\"design:type\", Object)], TreeModel.prototype, \"focusedNodeId\", void 0);\n\n  __decorate$1([observable$1, __metadata$1(\"design:type\", TreeNode)], TreeModel.prototype, \"virtualRoot\", void 0);\n\n  __decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"focusedNode\", null);\n\n  __decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"expandedNodes\", null);\n\n  __decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"activeNodes\", null);\n\n  __decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"hiddenNodes\", null);\n\n  __decorate$1([computed$1, __metadata$1(\"design:type\", Object), __metadata$1(\"design:paramtypes\", [])], TreeModel.prototype, \"selectedLeafNodes\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setData\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"update\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setFocusedNode\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setFocus\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"doForAll\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"focusNextNode\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"focusPreviousNode\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"focusDrillDown\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"focusDrillUp\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setActiveNode\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setSelectedNode\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setExpandedNode\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"expandAll\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"collapseAll\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setIsHidden\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setHiddenNodeIds\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"filterNodes\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", []), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"clearFilter\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"moveNode\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object, Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"copyNode\", null);\n\n  __decorate$1([action$1, __metadata$1(\"design:type\", Function), __metadata$1(\"design:paramtypes\", [Object]), __metadata$1(\"design:returntype\", void 0)], TreeModel.prototype, \"setState\", null);\n\n  return TreeModel;\n}();\n\nvar TreeDraggedElement = /*@__PURE__*/function () {\n  var TreeDraggedElement = /*#__PURE__*/function () {\n    function TreeDraggedElement() {\n      _classCallCheck(this, TreeDraggedElement);\n\n      this._draggedElement = null;\n    }\n\n    _createClass(TreeDraggedElement, [{\n      key: \"set\",\n      value: function set(draggedElement) {\n        this._draggedElement = draggedElement;\n      }\n    }, {\n      key: \"get\",\n      value: function get() {\n        return this._draggedElement;\n      }\n    }, {\n      key: \"isDragging\",\n      value: function isDragging() {\n        return !!this.get();\n      }\n    }]);\n\n    return TreeDraggedElement;\n  }();\n\n  TreeDraggedElement.ɵfac = function TreeDraggedElement_Factory(t) {\n    return new (t || TreeDraggedElement)();\n  };\n  /** @nocollapse */\n\n\n  TreeDraggedElement.ɵprov = ɵɵdefineInjectable({\n    factory: function TreeDraggedElement_Factory() {\n      return new TreeDraggedElement();\n    },\n    token: TreeDraggedElement,\n    providedIn: \"root\"\n  });\n  return TreeDraggedElement;\n}();\n\nvar __decorate$2 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata$2 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar Y_OFFSET = 500; // Extra pixels outside the viewport, in each direction, to render nodes in\n\nvar Y_EPSILON = 150; // Minimum pixel change required to recalculate the rendered nodes\n\nvar TreeVirtualScroll = /*@__PURE__*/function () {\n  var TreeVirtualScroll = /*#__PURE__*/function () {\n    function TreeVirtualScroll(treeModel) {\n      var _this15 = this;\n\n      _classCallCheck(this, TreeVirtualScroll);\n\n      this.treeModel = treeModel;\n      this.yBlocks = 0;\n      this.x = 0;\n      this.viewportHeight = null;\n      this.viewport = null;\n      treeModel.virtualScroll = this;\n      this._dispose = [autorun(function () {\n        return _this15.fixScroll();\n      })];\n    }\n\n    _createClass(TreeVirtualScroll, [{\n      key: \"y\",\n      get: function get() {\n        return this.yBlocks * Y_EPSILON;\n      }\n    }, {\n      key: \"totalHeight\",\n      get: function get() {\n        return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;\n      }\n    }, {\n      key: \"fireEvent\",\n      value: function fireEvent(event) {\n        this.treeModel.fireEvent(event);\n      }\n    }, {\n      key: \"init\",\n      value: function init() {\n        var _this16 = this;\n\n        var fn = this.recalcPositions.bind(this);\n        fn();\n        this._dispose = [].concat(_toConsumableArray(this._dispose), [reaction(function () {\n          return _this16.treeModel.roots;\n        }, fn), reaction(function () {\n          return _this16.treeModel.expandedNodeIds;\n        }, fn), reaction(function () {\n          return _this16.treeModel.hiddenNodeIds;\n        }, fn)]);\n        this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);\n      }\n    }, {\n      key: \"isEnabled\",\n      value: function isEnabled() {\n        return this.treeModel.options.useVirtualScroll;\n      }\n    }, {\n      key: \"_setYBlocks\",\n      value: function _setYBlocks(value) {\n        this.yBlocks = value;\n      }\n    }, {\n      key: \"recalcPositions\",\n      value: function recalcPositions() {\n        this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);\n      }\n    }, {\n      key: \"_getPositionAfter\",\n      value: function _getPositionAfter(nodes, startPos) {\n        var _this17 = this;\n\n        var position = startPos;\n        nodes.forEach(function (node) {\n          node.position = position;\n          position = _this17._getPositionAfterNode(node, position);\n        });\n        return position;\n      }\n    }, {\n      key: \"_getPositionAfterNode\",\n      value: function _getPositionAfterNode(node, startPos) {\n        var position = node.getSelfHeight() + startPos;\n\n        if (node.children && node.isExpanded) {\n          // TBD: consider loading component as well\n          position = this._getPositionAfter(node.visibleChildren, position);\n        }\n\n        node.height = position - startPos;\n        return position;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this._dispose.forEach(function (d) {\n          return d();\n        });\n      }\n    }, {\n      key: \"setViewport\",\n      value: function setViewport(viewport) {\n        Object.assign(this, {\n          viewport: viewport,\n          x: viewport.scrollLeft,\n          yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),\n          viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0\n        });\n      }\n    }, {\n      key: \"scrollIntoView\",\n      value: function scrollIntoView(node, force) {\n        var scrollToMiddle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n        if (node.options.scrollContainer) {\n          var scrollContainer = node.options.scrollContainer;\n          var scrollContainerHeight = scrollContainer.getBoundingClientRect().height;\n          var scrollContainerTop = scrollContainer.getBoundingClientRect().top;\n          var nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;\n\n          if (force || // force scroll to node\n          nodeTop < scrollContainer.scrollTop || // node is above scroll container\n          nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) {\n            // node is below container\n            scrollContainer.scrollTop = scrollToMiddle ? nodeTop - scrollContainerHeight / 2 : // scroll to middle\n            nodeTop; // scroll to start\n          }\n        } else {\n          if (force || // force scroll to node\n          node.position < this.y || // node is above viewport\n          node.position + node.getSelfHeight() > this.y + this.viewportHeight) {\n            // node is below viewport\n            if (this.viewport) {\n              this.viewport.scrollTop = scrollToMiddle ? node.position - this.viewportHeight / 2 : // scroll to middle\n              node.position; // scroll to start\n\n              this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));\n            }\n          }\n        }\n      }\n    }, {\n      key: \"getViewportNodes\",\n      value: function getViewportNodes(nodes) {\n        var _this18 = this;\n\n        if (!nodes) return [];\n        var visibleNodes = nodes.filter(function (node) {\n          return !node.isHidden;\n        });\n        if (!this.isEnabled()) return visibleNodes;\n        if (!this.viewportHeight || !visibleNodes.length) return []; // When loading children async this method is called before their height and position is calculated.\n        // In that case firstIndex === 0 and lastIndex === visibleNodes.length - 1 (e.g. 1000),\n        // which means that it loops through every visibleNodes item and push them into viewportNodes array.\n        // We can prevent nodes from being pushed to the array and wait for the appropriate calculations to take place\n\n        var lastVisibleNode = visibleNodes.slice(-1)[0];\n        if (!lastVisibleNode.height && lastVisibleNode.position === 0) return []; // Search for first node in the viewport using binary search\n        // Look for first node that starts after the beginning of the viewport (with buffer)\n        // Or that ends after the beginning of the viewport\n\n        var firstIndex = binarySearch(visibleNodes, function (node) {\n          return node.position + Y_OFFSET > _this18.y || node.position + node.height > _this18.y;\n        }); // Search for last node in the viewport using binary search\n        // Look for first node that starts after the end of the viewport (with buffer)\n\n        var lastIndex = binarySearch(visibleNodes, function (node) {\n          return node.position - Y_OFFSET > _this18.y + _this18.viewportHeight;\n        }, firstIndex);\n        var viewportNodes = [];\n\n        for (var i = firstIndex; i <= lastIndex; i++) {\n          viewportNodes.push(visibleNodes[i]);\n        }\n\n        return viewportNodes;\n      }\n    }, {\n      key: \"fixScroll\",\n      value: function fixScroll() {\n        var maxY = Math.max(0, this.totalHeight - this.viewportHeight);\n        if (this.y < 0) this._setYBlocks(0);\n        if (this.y > maxY) this._setYBlocks(maxY / Y_EPSILON);\n      }\n    }]);\n\n    return TreeVirtualScroll;\n  }();\n\n  TreeVirtualScroll.ɵfac = function TreeVirtualScroll_Factory(t) {\n    return new (t || TreeVirtualScroll)(ɵngcc0.ɵɵinject(TreeModel));\n  };\n\n  TreeVirtualScroll.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TreeVirtualScroll,\n    factory: TreeVirtualScroll.ɵfac\n  });\n\n  __decorate$2([observable$1, __metadata$2(\"design:type\", Object)], TreeVirtualScroll.prototype, \"yBlocks\", void 0);\n\n  __decorate$2([observable$1, __metadata$2(\"design:type\", Object)], TreeVirtualScroll.prototype, \"x\", void 0);\n\n  __decorate$2([observable$1, __metadata$2(\"design:type\", Object)], TreeVirtualScroll.prototype, \"viewportHeight\", void 0);\n\n  __decorate$2([computed$1, __metadata$2(\"design:type\", Object), __metadata$2(\"design:paramtypes\", [])], TreeVirtualScroll.prototype, \"y\", null);\n\n  __decorate$2([computed$1, __metadata$2(\"design:type\", Object), __metadata$2(\"design:paramtypes\", [])], TreeVirtualScroll.prototype, \"totalHeight\", null);\n\n  __decorate$2([action$1, __metadata$2(\"design:type\", Function), __metadata$2(\"design:paramtypes\", [Object]), __metadata$2(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"_setYBlocks\", null);\n\n  __decorate$2([action$1, __metadata$2(\"design:type\", Function), __metadata$2(\"design:paramtypes\", []), __metadata$2(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"recalcPositions\", null);\n\n  __decorate$2([action$1, __metadata$2(\"design:type\", Function), __metadata$2(\"design:paramtypes\", [Object]), __metadata$2(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"setViewport\", null);\n\n  __decorate$2([action$1, __metadata$2(\"design:type\", Function), __metadata$2(\"design:paramtypes\", [Object, Object, Object]), __metadata$2(\"design:returntype\", void 0)], TreeVirtualScroll.prototype, \"scrollIntoView\", null);\n\n  return TreeVirtualScroll;\n}();\n\nfunction binarySearch(nodes, condition) {\n  var firstIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var index = firstIndex;\n  var toIndex = nodes.length - 1;\n\n  while (index !== toIndex) {\n    var midIndex = Math.floor((index + toIndex) / 2);\n\n    if (condition(nodes[midIndex])) {\n      toIndex = midIndex;\n    } else {\n      if (index === midIndex) index = toIndex;else index = midIndex;\n    }\n  }\n\n  return index;\n}\n\nvar LoadingComponent = /*@__PURE__*/function () {\n  var LoadingComponent = function LoadingComponent() {\n    _classCallCheck(this, LoadingComponent);\n  };\n\n  LoadingComponent.ɵfac = function LoadingComponent_Factory(t) {\n    return new (t || LoadingComponent)();\n  };\n\n  LoadingComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: LoadingComponent,\n    selectors: [[\"tree-loading-component\"]],\n    inputs: {\n      template: \"template\",\n      node: \"node\"\n    },\n    decls: 2,\n    vars: 5,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function LoadingComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, LoadingComponent_span_0_Template, 2, 0, \"span\", 0);\n        ɵngcc0.ɵɵelementContainer(1, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(3, _c0, ctx.node));\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return LoadingComponent;\n}();\n\nvar TreeViewportComponent = /*@__PURE__*/function () {\n  var TreeViewportComponent = /*#__PURE__*/function () {\n    function TreeViewportComponent(elementRef, virtualScroll) {\n      var _this19 = this;\n\n      _classCallCheck(this, TreeViewportComponent);\n\n      this.elementRef = elementRef;\n      this.virtualScroll = virtualScroll;\n      this.setViewport = this.throttle(function () {\n        _this19.virtualScroll.setViewport(_this19.elementRef.nativeElement);\n      }, 17);\n      this.scrollEventHandler = this.setViewport.bind(this);\n    }\n\n    _createClass(TreeViewportComponent, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        this.virtualScroll.init();\n      }\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this20 = this;\n\n        setTimeout(function () {\n          _this20.setViewport();\n\n          _this20.virtualScroll.fireEvent({\n            eventName: TREE_EVENTS.initialized\n          });\n        });\n        var el = this.elementRef.nativeElement;\n        el.addEventListener('scroll', this.scrollEventHandler);\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.virtualScroll.clear();\n        var el = this.elementRef.nativeElement;\n        el.removeEventListener('scroll', this.scrollEventHandler);\n      }\n    }, {\n      key: \"getTotalHeight\",\n      value: function getTotalHeight() {\n        return this.virtualScroll.isEnabled() && this.virtualScroll.totalHeight + 'px' || 'auto';\n      }\n    }, {\n      key: \"throttle\",\n      value: function throttle(func, timeFrame) {\n        var lastTime = 0;\n        return function () {\n          var now = Date.now();\n\n          if (now - lastTime >= timeFrame) {\n            func();\n            lastTime = now;\n          }\n        };\n      }\n    }]);\n\n    return TreeViewportComponent;\n  }();\n\n  TreeViewportComponent.ɵfac = function TreeViewportComponent_Factory(t) {\n    return new (t || TreeViewportComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(TreeVirtualScroll));\n  };\n\n  TreeViewportComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeViewportComponent,\n    selectors: [[\"tree-viewport\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([TreeVirtualScroll])],\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"]],\n    template: function TreeViewportComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, TreeViewportComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: [TreeMobxAutorunDirective],\n    encapsulation: 2\n  });\n  return TreeViewportComponent;\n}();\n\nvar TreeComponent = /*@__PURE__*/function () {\n  var TreeComponent = /*#__PURE__*/function () {\n    function TreeComponent(treeModel, treeDraggedElement) {\n      var _this21 = this;\n\n      _classCallCheck(this, TreeComponent);\n\n      this.treeModel = treeModel;\n      this.treeDraggedElement = treeDraggedElement;\n      treeModel.eventNames.forEach(function (name) {\n        return _this21[name] = new EventEmitter();\n      });\n      treeModel.subscribeToState(function (state) {\n        return _this21.stateChange.emit(state);\n      });\n    } // Will be handled in ngOnChanges\n\n\n    _createClass(TreeComponent, [{\n      key: \"nodes\",\n      set: function set(nodes) {}\n    }, {\n      key: \"options\",\n      set: function set(options) {}\n    }, {\n      key: \"focused\",\n      set: function set(value) {\n        this.treeModel.setFocus(value);\n      }\n    }, {\n      key: \"state\",\n      set: function set(state) {\n        this.treeModel.setState(state);\n      }\n    }, {\n      key: \"onKeydown\",\n      value: function onKeydown($event) {\n        if (!this.treeModel.isFocused) return;\n        if (['input', 'textarea'].includes(document.activeElement.tagName.toLowerCase())) return;\n        var focusedNode = this.treeModel.getFocusedNode();\n        this.treeModel.performKeyAction(focusedNode, $event);\n      }\n    }, {\n      key: \"onMousedown\",\n      value: function onMousedown($event) {\n        function isOutsideClick(startElement, nodeName) {\n          return !startElement ? true : startElement.localName === nodeName ? false : isOutsideClick(startElement.parentElement, nodeName);\n        }\n\n        if (isOutsideClick($event.target, 'tree-root')) {\n          this.treeModel.setFocus(false);\n        }\n      }\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (changes.options || changes.nodes) {\n          this.treeModel.setData({\n            options: changes.options && changes.options.currentValue,\n            nodes: changes.nodes && changes.nodes.currentValue,\n            events: this.pick(this, this.treeModel.eventNames)\n          });\n        }\n      }\n    }, {\n      key: \"sizeChanged\",\n      value: function sizeChanged() {\n        this.viewportComponent.setViewport();\n      }\n    }, {\n      key: \"pick\",\n      value: function pick(object, keys) {\n        return keys.reduce(function (obj, key) {\n          if (object && object.hasOwnProperty(key)) {\n            obj[key] = object[key];\n          }\n\n          return obj;\n        }, {});\n      }\n    }]);\n\n    return TreeComponent;\n  }();\n\n  TreeComponent.ɵfac = function TreeComponent_Factory(t) {\n    return new (t || TreeComponent)(ɵngcc0.ɵɵdirectiveInject(TreeModel), ɵngcc0.ɵɵdirectiveInject(TreeDraggedElement));\n  };\n\n  TreeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeComponent,\n    selectors: [[\"Tree\"], [\"tree-root\"]],\n    contentQueries: function TreeComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c3, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c4, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c5, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c6, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.treeNodeTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.treeNodeWrapperTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.treeNodeFullTemplate = _t.first);\n      }\n    },\n    viewQuery: function TreeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c7, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewportComponent = _t.first);\n      }\n    },\n    hostBindings: function TreeComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"keydown\", function TreeComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeydown($event);\n        }, false, ɵngcc0.ɵɵresolveBody)(\"mousedown\", function TreeComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMousedown($event);\n        }, false, ɵngcc0.ɵɵresolveBody);\n      }\n    },\n    inputs: {\n      nodes: \"nodes\",\n      options: \"options\",\n      focused: \"focused\",\n      state: \"state\"\n    },\n    outputs: {\n      toggleExpanded: \"toggleExpanded\",\n      activate: \"activate\",\n      deactivate: \"deactivate\",\n      nodeActivate: \"nodeActivate\",\n      nodeDeactivate: \"nodeDeactivate\",\n      select: \"select\",\n      deselect: \"deselect\",\n      focus: \"focus\",\n      blur: \"blur\",\n      updateData: \"updateData\",\n      initialized: \"initialized\",\n      moveNode: \"moveNode\",\n      copyNode: \"copyNode\",\n      loadNodeChildren: \"loadNodeChildren\",\n      changeFilter: \"changeFilter\",\n      event: \"event\",\n      stateChange: \"stateChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([TreeModel]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 6,\n    consts: [[\"viewport\", \"\"], [1, \"angular-tree-component\"], [3, \"nodes\", \"treeModel\", \"templates\", 4, \"ngIf\"], [\"class\", \"empty-tree-drop-slot\", 3, \"dropIndex\", \"node\", 4, \"ngIf\"], [3, \"nodes\", \"treeModel\", \"templates\"], [1, \"empty-tree-drop-slot\", 3, \"dropIndex\", \"node\"]],\n    template: function TreeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"tree-viewport\", null, 0);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 1);\n        ɵngcc0.ɵɵtemplate(3, TreeComponent_tree_node_collection_3_Template, 1, 8, \"tree-node-collection\", 2);\n        ɵngcc0.ɵɵtemplate(4, TreeComponent_tree_node_drop_slot_4_Template, 1, 2, \"tree-node-drop-slot\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵclassProp(\"node-dragging\", ctx.treeDraggedElement.isDragging())(\"angular-tree-component-rtl\", ctx.treeModel.options.rtl);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.treeModel.roots);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.treeModel.isEmptyTree());\n      }\n    },\n    directives: function directives() {\n      return [TreeViewportComponent, ɵngcc1.NgIf, TreeNodeCollectionComponent, TreeNodeDropSlot];\n    },\n    encapsulation: 2\n  });\n  return TreeComponent;\n}();\n\nvar TreeNodeComponent = /*@__PURE__*/function () {\n  var TreeNodeComponent = function TreeNodeComponent() {\n    _classCallCheck(this, TreeNodeComponent);\n  };\n\n  TreeNodeComponent.ɵfac = function TreeNodeComponent_Factory(t) {\n    return new (t || TreeNodeComponent)();\n  };\n\n  TreeNodeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeComponent,\n    selectors: [[\"TreeNode\"], [\"tree-node\"]],\n    inputs: {\n      node: \"node\",\n      index: \"index\",\n      templates: \"templates\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [3, \"class\", \"tree-node\", \"tree-node-expanded\", \"tree-node-collapsed\", \"tree-node-leaf\", \"tree-node-active\", \"tree-node-focused\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"dropIndex\", \"node\", 4, \"ngIf\"], [3, \"node\", \"index\", \"templates\"], [3, \"node\", \"templates\"], [3, \"dropIndex\", \"node\"]],\n    template: function TreeNodeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeComponent_ng_container_0_Template, 3, 8, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: function directives() {\n      return [TreeMobxAutorunDirective, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, TreeNodeWrapperComponent, TreeNodeChildrenComponent, TreeNodeDropSlot];\n    },\n    encapsulation: 2\n  });\n  return TreeNodeComponent;\n}();\n\nvar TreeNodeContent = /*@__PURE__*/function () {\n  var TreeNodeContent = function TreeNodeContent() {\n    _classCallCheck(this, TreeNodeContent);\n  };\n\n  TreeNodeContent.ɵfac = function TreeNodeContent_Factory(t) {\n    return new (t || TreeNodeContent)();\n  };\n\n  TreeNodeContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeContent,\n    selectors: [[\"tree-node-content\"]],\n    inputs: {\n      node: \"node\",\n      index: \"index\",\n      template: \"template\"\n    },\n    decls: 2,\n    vars: 7,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function TreeNodeContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeContent_span_0_Template, 2, 1, \"span\", 0);\n        ɵngcc0.ɵɵelementContainer(1, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction3(3, _c10, ctx.node, ctx.node, ctx.index));\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return TreeNodeContent;\n}();\n\nvar TreeNodeDropSlot = /*@__PURE__*/function () {\n  var TreeNodeDropSlot = /*#__PURE__*/function () {\n    function TreeNodeDropSlot() {\n      _classCallCheck(this, TreeNodeDropSlot);\n    }\n\n    _createClass(TreeNodeDropSlot, [{\n      key: \"onDrop\",\n      value: function onDrop($event) {\n        this.node.mouseAction('drop', $event.event, {\n          from: $event.element,\n          to: {\n            parent: this.node,\n            index: this.dropIndex\n          }\n        });\n      }\n    }, {\n      key: \"allowDrop\",\n      value: function allowDrop(element, $event) {\n        return this.node.options.allowDrop(element, {\n          parent: this.node,\n          index: this.dropIndex\n        }, $event);\n      }\n    }]);\n\n    return TreeNodeDropSlot;\n  }();\n\n  TreeNodeDropSlot.ɵfac = function TreeNodeDropSlot_Factory(t) {\n    return new (t || TreeNodeDropSlot)();\n  };\n\n  TreeNodeDropSlot.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeDropSlot,\n    selectors: [[\"TreeNodeDropSlot\"], [\"tree-node-drop-slot\"]],\n    inputs: {\n      node: \"node\",\n      dropIndex: \"dropIndex\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[1, \"node-drop-slot\", 3, \"treeAllowDrop\", \"allowDragoverStyling\", \"treeDrop\"]],\n    template: function TreeNodeDropSlot_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵlistener(\"treeDrop\", function TreeNodeDropSlot_Template_div_treeDrop_0_listener($event) {\n          return ctx.onDrop($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeAllowDrop\", ctx.allowDrop.bind(ctx))(\"allowDragoverStyling\", true);\n      }\n    },\n    directives: function directives() {\n      return [TreeDropDirective];\n    },\n    encapsulation: 2\n  });\n  return TreeNodeDropSlot;\n}();\n\nvar TreeNodeExpanderComponent = /*@__PURE__*/function () {\n  var TreeNodeExpanderComponent = function TreeNodeExpanderComponent() {\n    _classCallCheck(this, TreeNodeExpanderComponent);\n  };\n\n  TreeNodeExpanderComponent.ɵfac = function TreeNodeExpanderComponent_Factory(t) {\n    return new (t || TreeNodeExpanderComponent)();\n  };\n\n  TreeNodeExpanderComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeExpanderComponent,\n    selectors: [[\"tree-node-expander\"]],\n    inputs: {\n      node: \"node\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [\"class\", \"toggle-children-wrapper\", 3, \"toggle-children-wrapper-expanded\", \"toggle-children-wrapper-collapsed\", \"click\", 4, \"ngIf\"], [\"class\", \"toggle-children-placeholder\", 4, \"ngIf\"], [1, \"toggle-children-wrapper\", 3, \"click\"], [1, \"toggle-children\"], [1, \"toggle-children-placeholder\"]],\n    template: function TreeNodeExpanderComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeExpanderComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: [TreeMobxAutorunDirective, ɵngcc1.NgIf],\n    encapsulation: 2\n  });\n  return TreeNodeExpanderComponent;\n}();\n\nvar TreeNodeChildrenComponent = /*@__PURE__*/function () {\n  var TreeNodeChildrenComponent = function TreeNodeChildrenComponent() {\n    _classCallCheck(this, TreeNodeChildrenComponent);\n  };\n\n  TreeNodeChildrenComponent.ɵfac = function TreeNodeChildrenComponent_Factory(t) {\n    return new (t || TreeNodeChildrenComponent)();\n  };\n\n  TreeNodeChildrenComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeChildrenComponent,\n    selectors: [[\"tree-node-children\"]],\n    inputs: {\n      node: \"node\",\n      templates: \"templates\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [3, \"tree-children\", \"tree-children-no-padding\", 4, \"treeAnimateOpen\", \"treeAnimateOpenSpeed\", \"treeAnimateOpenAcceleration\", \"treeAnimateOpenEnabled\"], [3, \"nodes\", \"templates\", \"treeModel\", 4, \"ngIf\"], [\"class\", \"tree-node-loading\", 3, \"padding-left\", \"template\", \"node\", 4, \"ngIf\"], [3, \"nodes\", \"templates\", \"treeModel\"], [1, \"tree-node-loading\", 3, \"template\", \"node\"]],\n    template: function TreeNodeChildrenComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeChildrenComponent_ng_container_0_Template, 2, 4, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: function directives() {\n      return [TreeMobxAutorunDirective, TreeAnimateOpenDirective, ɵngcc1.NgIf, TreeNodeCollectionComponent, LoadingComponent];\n    },\n    encapsulation: 2\n  });\n  return TreeNodeChildrenComponent;\n}(); // Re-export mobx operators to be able to use inside components with AOT:\n\n\nfunction actionInternal() {\n  return action$1.apply(void 0, arguments);\n}\n\nvar action = Object.assign(actionInternal, action$1);\n\nfunction computedInternal() {\n  return computed$1.apply(void 0, arguments);\n}\n\nvar computed = Object.assign(computedInternal, computed$1);\n\nfunction observableInternal() {\n  return observable$1.apply(void 0, arguments);\n}\n\nvar observable = Object.assign(observableInternal, observable$1);\n\nvar __decorate$3 = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata$3 = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar TreeNodeCollectionComponent = /*@__PURE__*/function () {\n  var TreeNodeCollectionComponent = /*#__PURE__*/function () {\n    function TreeNodeCollectionComponent() {\n      _classCallCheck(this, TreeNodeCollectionComponent);\n\n      this._dispose = [];\n    }\n\n    _createClass(TreeNodeCollectionComponent, [{\n      key: \"nodes\",\n      get: function get() {\n        return this._nodes;\n      },\n      set: function set(nodes) {\n        this.setNodes(nodes);\n      }\n    }, {\n      key: \"marginTop\",\n      get: function get() {\n        var firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];\n        var relativePosition = firstNode && firstNode.parent ? firstNode.position - firstNode.parent.position - firstNode.parent.getSelfHeight() : 0;\n        return \"\".concat(relativePosition, \"px\");\n      }\n    }, {\n      key: \"setNodes\",\n      value: function setNodes(nodes) {\n        this._nodes = nodes;\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this22 = this;\n\n        this.virtualScroll = this.treeModel.virtualScroll;\n        this._dispose = [// return node indexes so we can compare structurally,\n        reaction(function () {\n          return _this22.virtualScroll.getViewportNodes(_this22.nodes).map(function (n) {\n            return n.index;\n          });\n        }, function (nodeIndexes) {\n          _this22.viewportNodes = nodeIndexes.map(function (i) {\n            return _this22.nodes[i];\n          });\n        }, {\n          compareStructural: true,\n          fireImmediately: true\n        }), reaction(function () {\n          return _this22.nodes;\n        }, function (nodes) {\n          _this22.viewportNodes = _this22.virtualScroll.getViewportNodes(nodes);\n        })];\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this._dispose.forEach(function (d) {\n          return d();\n        });\n      }\n    }, {\n      key: \"trackNode\",\n      value: function trackNode(index, node) {\n        return node.id;\n      }\n    }]);\n\n    return TreeNodeCollectionComponent;\n  }();\n\n  TreeNodeCollectionComponent.ɵfac = function TreeNodeCollectionComponent_Factory(t) {\n    return new (t || TreeNodeCollectionComponent)();\n  };\n\n  TreeNodeCollectionComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeCollectionComponent,\n    selectors: [[\"tree-node-collection\"]],\n    inputs: {\n      nodes: \"nodes\",\n      treeModel: \"treeModel\",\n      templates: \"templates\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [3, \"node\", \"index\", \"templates\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"node\", \"index\", \"templates\"]],\n    template: function TreeNodeCollectionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeCollectionComponent_ng_container_0_Template, 3, 4, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: [TreeMobxAutorunDirective, ɵngcc1.NgForOf, TreeNodeComponent],\n    encapsulation: 2\n  });\n\n  __decorate$3([observable, __metadata$3(\"design:type\", Object)], TreeNodeCollectionComponent.prototype, \"_nodes\", void 0);\n\n  __decorate$3([observable, __metadata$3(\"design:type\", Array)], TreeNodeCollectionComponent.prototype, \"viewportNodes\", void 0);\n\n  __decorate$3([computed, __metadata$3(\"design:type\", String), __metadata$3(\"design:paramtypes\", [])], TreeNodeCollectionComponent.prototype, \"marginTop\", null);\n\n  __decorate$3([action, __metadata$3(\"design:type\", Function), __metadata$3(\"design:paramtypes\", [Object]), __metadata$3(\"design:returntype\", void 0)], TreeNodeCollectionComponent.prototype, \"setNodes\", null);\n\n  return TreeNodeCollectionComponent;\n}();\n\nvar TreeNodeWrapperComponent = /*@__PURE__*/function () {\n  var TreeNodeWrapperComponent = function TreeNodeWrapperComponent() {\n    _classCallCheck(this, TreeNodeWrapperComponent);\n  };\n\n  TreeNodeWrapperComponent.ɵfac = function TreeNodeWrapperComponent_Factory(t) {\n    return new (t || TreeNodeWrapperComponent)();\n  };\n\n  TreeNodeWrapperComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeWrapperComponent,\n    selectors: [[\"tree-node-wrapper\"]],\n    inputs: {\n      node: \"node\",\n      index: \"index\",\n      templates: \"templates\"\n    },\n    decls: 2,\n    vars: 8,\n    consts: [[\"class\", \"node-wrapper\", 3, \"padding-left\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"node-wrapper\"], [3, \"node\", 4, \"ngIf\"], [3, \"node\"], [1, \"node-content-wrapper\", 3, \"treeAllowDrop\", \"allowDragoverStyling\", \"treeDrag\", \"treeDragEnabled\", \"click\", \"dblclick\", \"mouseover\", \"mouseout\", \"contextmenu\", \"treeDrop\", \"treeDropDragOver\", \"treeDropDragLeave\", \"treeDropDragEnter\"], [3, \"node\", \"index\", \"template\"]],\n    template: function TreeNodeWrapperComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeWrapperComponent_div_0_Template, 5, 15, \"div\", 0);\n        ɵngcc0.ɵɵelementContainer(1, 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.templates.treeNodeWrapperTemplate);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.templates.treeNodeWrapperTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction4(3, _c9, ctx.node, ctx.node, ctx.index, ctx.templates));\n      }\n    },\n    directives: function directives() {\n      return [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, TreeNodeExpanderComponent, TreeDragDirective, TreeDropDirective, TreeNodeContent, TreeNodeCheckboxComponent];\n    },\n    encapsulation: 2\n  });\n  return TreeNodeWrapperComponent;\n}();\n\nvar TreeNodeCheckboxComponent = /*@__PURE__*/function () {\n  var TreeNodeCheckboxComponent = function TreeNodeCheckboxComponent() {\n    _classCallCheck(this, TreeNodeCheckboxComponent);\n  };\n\n  TreeNodeCheckboxComponent.ɵfac = function TreeNodeCheckboxComponent_Factory(t) {\n    return new (t || TreeNodeCheckboxComponent)();\n  };\n\n  TreeNodeCheckboxComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TreeNodeCheckboxComponent,\n    selectors: [[\"tree-node-checkbox\"]],\n    inputs: {\n      node: \"node\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[4, \"treeMobxAutorun\"], [\"type\", \"checkbox\", 1, \"tree-node-checkbox\", 3, \"checked\", \"indeterminate\", \"click\"]],\n    template: function TreeNodeCheckboxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TreeNodeCheckboxComponent_ng_container_0_Template, 2, 2, \"ng-container\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"treeMobxAutorun\", ɵngcc0.ɵɵpureFunction0(1, _c1));\n      }\n    },\n    directives: [TreeMobxAutorunDirective],\n    encapsulation: 2\n  });\n  return TreeNodeCheckboxComponent;\n}();\n\nvar DRAG_OVER_CLASS = 'is-dragging-over';\nvar DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';\n\nvar TreeDropDirective = /*@__PURE__*/function () {\n  var TreeDropDirective = /*#__PURE__*/function () {\n    function TreeDropDirective(el, renderer, treeDraggedElement, ngZone) {\n      _classCallCheck(this, TreeDropDirective);\n\n      this.el = el;\n      this.renderer = renderer;\n      this.treeDraggedElement = treeDraggedElement;\n      this.ngZone = ngZone;\n      this.allowDragoverStyling = true;\n      this.onDropCallback = new EventEmitter();\n      this.onDragOverCallback = new EventEmitter();\n      this.onDragLeaveCallback = new EventEmitter();\n      this.onDragEnterCallback = new EventEmitter();\n\n      this._allowDrop = function (element, $event) {\n        return true;\n      };\n\n      this.dragOverEventHandler = this.onDragOver.bind(this);\n      this.dragEnterEventHandler = this.onDragEnter.bind(this);\n      this.dragLeaveEventHandler = this.onDragLeave.bind(this);\n    }\n\n    _createClass(TreeDropDirective, [{\n      key: \"treeAllowDrop\",\n      set: function set(allowDrop) {\n        if (allowDrop instanceof Function) {\n          this._allowDrop = allowDrop;\n        } else this._allowDrop = function (element, $event) {\n          return allowDrop;\n        };\n      }\n    }, {\n      key: \"allowDrop\",\n      value: function allowDrop($event) {\n        return this._allowDrop(this.treeDraggedElement.get(), $event);\n      }\n    }, {\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this23 = this;\n\n        var el = this.el.nativeElement;\n        this.ngZone.runOutsideAngular(function () {\n          el.addEventListener('dragover', _this23.dragOverEventHandler);\n          el.addEventListener('dragenter', _this23.dragEnterEventHandler);\n          el.addEventListener('dragleave', _this23.dragLeaveEventHandler);\n        });\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var el = this.el.nativeElement;\n        el.removeEventListener('dragover', this.dragOverEventHandler);\n        el.removeEventListener('dragenter', this.dragEnterEventHandler);\n        el.removeEventListener('dragleave', this.dragLeaveEventHandler);\n      }\n    }, {\n      key: \"onDragOver\",\n      value: function onDragOver($event) {\n        if (!this.allowDrop($event)) {\n          if (this.allowDragoverStyling) {\n            return this.addDisabledClass();\n          }\n\n          return;\n        }\n\n        this.onDragOverCallback.emit({\n          event: $event,\n          element: this.treeDraggedElement.get()\n        });\n        $event.preventDefault();\n\n        if (this.allowDragoverStyling) {\n          this.addClass();\n        }\n      }\n    }, {\n      key: \"onDragEnter\",\n      value: function onDragEnter($event) {\n        if (!this.allowDrop($event)) return;\n        $event.preventDefault();\n        this.onDragEnterCallback.emit({\n          event: $event,\n          element: this.treeDraggedElement.get()\n        });\n      }\n    }, {\n      key: \"onDragLeave\",\n      value: function onDragLeave($event) {\n        if (!this.allowDrop($event)) {\n          if (this.allowDragoverStyling) {\n            return this.removeDisabledClass();\n          }\n\n          return;\n        }\n\n        this.onDragLeaveCallback.emit({\n          event: $event,\n          element: this.treeDraggedElement.get()\n        });\n\n        if (this.allowDragoverStyling) {\n          this.removeClass();\n        }\n      }\n    }, {\n      key: \"onDrop\",\n      value: function onDrop($event) {\n        if (!this.allowDrop($event)) return;\n        $event.preventDefault();\n        this.onDropCallback.emit({\n          event: $event,\n          element: this.treeDraggedElement.get()\n        });\n\n        if (this.allowDragoverStyling) {\n          this.removeClass();\n        }\n\n        this.treeDraggedElement.set(null);\n      }\n    }, {\n      key: \"addClass\",\n      value: function addClass() {\n        this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS);\n      }\n    }, {\n      key: \"removeClass\",\n      value: function removeClass() {\n        this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS);\n      }\n    }, {\n      key: \"addDisabledClass\",\n      value: function addDisabledClass() {\n        this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\n      }\n    }, {\n      key: \"removeDisabledClass\",\n      value: function removeDisabledClass() {\n        this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);\n      }\n    }]);\n\n    return TreeDropDirective;\n  }();\n\n  TreeDropDirective.ɵfac = function TreeDropDirective_Factory(t) {\n    return new (t || TreeDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(TreeDraggedElement), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  TreeDropDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeDropDirective,\n    selectors: [[\"\", \"treeDrop\", \"\"]],\n    hostBindings: function TreeDropDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"drop\", function TreeDropDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        });\n      }\n    },\n    inputs: {\n      allowDragoverStyling: \"allowDragoverStyling\",\n      treeAllowDrop: \"treeAllowDrop\"\n    },\n    outputs: {\n      onDropCallback: \"treeDrop\",\n      onDragOverCallback: \"treeDropDragOver\",\n      onDragLeaveCallback: \"treeDropDragLeave\",\n      onDragEnterCallback: \"treeDropDragEnter\"\n    }\n  });\n  return TreeDropDirective;\n}();\n\nvar DRAG_OVER_CLASS$1 = 'is-dragging-over';\n\nvar TreeDragDirective = /*@__PURE__*/function () {\n  var TreeDragDirective = /*#__PURE__*/function () {\n    function TreeDragDirective(el, renderer, treeDraggedElement, ngZone) {\n      _classCallCheck(this, TreeDragDirective);\n\n      this.el = el;\n      this.renderer = renderer;\n      this.treeDraggedElement = treeDraggedElement;\n      this.ngZone = ngZone;\n      this.dragEventHandler = this.onDrag.bind(this);\n    }\n\n    _createClass(TreeDragDirective, [{\n      key: \"ngAfterViewInit\",\n      value: function ngAfterViewInit() {\n        var _this24 = this;\n\n        var el = this.el.nativeElement;\n        this.ngZone.runOutsideAngular(function () {\n          el.addEventListener('drag', _this24.dragEventHandler);\n        });\n      }\n    }, {\n      key: \"ngDoCheck\",\n      value: function ngDoCheck() {\n        this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var el = this.el.nativeElement;\n        el.removeEventListener('drag', this.dragEventHandler);\n      }\n    }, {\n      key: \"onDragStart\",\n      value: function onDragStart(ev) {\n        // setting the data is required by firefox\n        ev.dataTransfer.setData('text', ev.target.id);\n        this.treeDraggedElement.set(this.draggedElement);\n\n        if (this.draggedElement.mouseAction) {\n          this.draggedElement.mouseAction('dragStart', ev);\n        }\n      }\n    }, {\n      key: \"onDrag\",\n      value: function onDrag(ev) {\n        if (this.draggedElement.mouseAction) {\n          this.draggedElement.mouseAction('drag', ev);\n        }\n      }\n    }, {\n      key: \"onDragEnd\",\n      value: function onDragEnd() {\n        if (this.draggedElement.mouseAction) {\n          this.draggedElement.mouseAction('dragEnd');\n        }\n\n        this.treeDraggedElement.set(null);\n      }\n    }]);\n\n    return TreeDragDirective;\n  }();\n\n  TreeDragDirective.ɵfac = function TreeDragDirective_Factory(t) {\n    return new (t || TreeDragDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(TreeDraggedElement), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  TreeDragDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeDragDirective,\n    selectors: [[\"\", \"treeDrag\", \"\"]],\n    hostBindings: function TreeDragDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"dragstart\", function TreeDragDirective_dragstart_HostBindingHandler($event) {\n          return ctx.onDragStart($event);\n        })(\"dragend\", function TreeDragDirective_dragend_HostBindingHandler() {\n          return ctx.onDragEnd();\n        });\n      }\n    },\n    inputs: {\n      draggedElement: [\"treeDrag\", \"draggedElement\"],\n      treeDragEnabled: \"treeDragEnabled\"\n    }\n  });\n  return TreeDragDirective;\n}();\n\nvar EASE_ACCELERATION = 1.005;\n\nvar TreeAnimateOpenDirective = /*@__PURE__*/function () {\n  var TreeAnimateOpenDirective = /*#__PURE__*/function () {\n    function TreeAnimateOpenDirective(renderer, templateRef, viewContainerRef) {\n      _classCallCheck(this, TreeAnimateOpenDirective);\n\n      this.renderer = renderer;\n      this.templateRef = templateRef;\n      this.viewContainerRef = viewContainerRef;\n    }\n\n    _createClass(TreeAnimateOpenDirective, [{\n      key: \"isOpen\",\n      set: function set(value) {\n        if (value) {\n          this._show();\n\n          if (this.isEnabled && this._isOpen === false) {\n            this._animateOpen();\n          }\n        } else {\n          this.isEnabled ? this._animateClose() : this._hide();\n        }\n\n        this._isOpen = !!value;\n      }\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        if (this.innerElement) return; // create child view\n\n        this.innerElement = this.viewContainerRef.createEmbeddedView(this.templateRef).rootNodes[0];\n      }\n    }, {\n      key: \"_hide\",\n      value: function _hide() {\n        this.viewContainerRef.clear();\n        this.innerElement = null;\n      }\n    }, {\n      key: \"_animateOpen\",\n      value: function _animateOpen() {\n        var _this25 = this;\n\n        var delta = this.animateSpeed;\n        var ease = this.animateAcceleration;\n        var maxHeight = 0; // set height to 0\n\n        this.renderer.setStyle(this.innerElement, 'max-height', \"0\"); // increase maxHeight until height doesn't change\n\n        setTimeout(function () {\n          var i = setInterval(function () {\n            if (!_this25._isOpen || !_this25.innerElement) return clearInterval(i);\n            maxHeight += delta;\n            var roundedMaxHeight = Math.round(maxHeight);\n\n            _this25.renderer.setStyle(_this25.innerElement, 'max-height', \"\".concat(roundedMaxHeight, \"px\"));\n\n            var height = _this25.innerElement.getBoundingClientRect ? _this25.innerElement.getBoundingClientRect().height : 0; // TBD use renderer\n\n            delta *= ease;\n            ease *= EASE_ACCELERATION;\n\n            if (height < roundedMaxHeight) {\n              // Make maxHeight auto because animation finished and container might change height later on\n              _this25.renderer.setStyle(_this25.innerElement, 'max-height', null);\n\n              clearInterval(i);\n            }\n          }, 17);\n        });\n      }\n    }, {\n      key: \"_animateClose\",\n      value: function _animateClose() {\n        var _this26 = this;\n\n        if (!this.innerElement) return;\n        var delta = this.animateSpeed;\n        var ease = this.animateAcceleration;\n        var height = this.innerElement.getBoundingClientRect().height; // TBD use renderer\n        // slowly decrease maxHeight to 0, starting from current height\n\n        var i = setInterval(function () {\n          if (_this26._isOpen || !_this26.innerElement) return clearInterval(i);\n          height -= delta;\n\n          _this26.renderer.setStyle(_this26.innerElement, 'max-height', \"\".concat(height, \"px\"));\n\n          delta *= ease;\n          ease *= EASE_ACCELERATION;\n\n          if (height <= 0) {\n            // after animation complete - remove child element\n            _this26.viewContainerRef.clear();\n\n            _this26.innerElement = null;\n            clearInterval(i);\n          }\n        }, 17);\n      }\n    }]);\n\n    return TreeAnimateOpenDirective;\n  }();\n\n  TreeAnimateOpenDirective.ɵfac = function TreeAnimateOpenDirective_Factory(t) {\n    return new (t || TreeAnimateOpenDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  TreeAnimateOpenDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TreeAnimateOpenDirective,\n    selectors: [[\"\", \"treeAnimateOpen\", \"\"]],\n    inputs: {\n      isOpen: [\"treeAnimateOpen\", \"isOpen\"],\n      animateSpeed: [\"treeAnimateOpenSpeed\", \"animateSpeed\"],\n      animateAcceleration: [\"treeAnimateOpenAcceleration\", \"animateAcceleration\"],\n      isEnabled: [\"treeAnimateOpenEnabled\", \"isEnabled\"]\n    }\n  });\n  return TreeAnimateOpenDirective;\n}();\n\nvar TreeModule = /*@__PURE__*/function () {\n  var TreeModule = function TreeModule() {\n    _classCallCheck(this, TreeModule);\n  };\n\n  TreeModule.ɵfac = function TreeModule_Factory(t) {\n    return new (t || TreeModule)();\n  };\n\n  TreeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TreeModule\n  });\n  TreeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[CommonModule]]\n  });\n  return TreeModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeModule, {\n    declarations: function declarations() {\n      return [TreeComponent, TreeNodeComponent, TreeNodeContent, LoadingComponent, TreeDropDirective, TreeDragDirective, TreeNodeExpanderComponent, TreeNodeChildrenComponent, TreeNodeDropSlot, TreeNodeCollectionComponent, TreeViewportComponent, TreeNodeWrapperComponent, TreeNodeCheckboxComponent, TreeAnimateOpenDirective, TreeMobxAutorunDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [TreeComponent, TreeNodeComponent, TreeNodeContent, LoadingComponent, TreeDropDirective, TreeDragDirective, TreeNodeExpanderComponent, TreeNodeChildrenComponent, TreeNodeDropSlot, TreeNodeCollectionComponent, TreeViewportComponent, TreeNodeWrapperComponent, TreeNodeCheckboxComponent, TreeAnimateOpenDirective, TreeMobxAutorunDirective];\n    }\n  });\n})();\n/*\n * Public API Surface of angular-tree-component\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { KEYS, LoadingComponent, TREE_ACTIONS, TreeAnimateOpenDirective, TreeComponent, TreeDragDirective, TreeDraggedElement, TreeDropDirective, TreeModel, TreeModule, TreeNode, TreeNodeCheckboxComponent, TreeNodeChildrenComponent, TreeNodeCollectionComponent, TreeNodeComponent, TreeNodeContent, TreeNodeDropSlot, TreeNodeExpanderComponent, TreeNodeWrapperComponent, TreeViewportComponent, TreeVirtualScroll, actionInternal as ɵa, action as ɵb, computed as ɵc, observable as ɵd, TreeMobxAutorunDirective as ɵe }; //# sourceMappingURL=circlon-angular-tree-component.js.map","map":null,"metadata":{},"sourceType":"module"}