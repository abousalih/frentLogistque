{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/mac/Apps/sr-manager/frontend/web/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _createClass from \"/Users/mac/Apps/sr-manager/frontend/web/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/mac/Apps/sr-manager/frontend/web/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { ElementRef, ɵɵdefineInjectable, ɵɵinject, INJECTOR, Injectable, Injector, EventEmitter, Directive, Input, Output, HostListener, Component, NgModule } from '@angular/core';\nimport { Overlay, ScrollStrategyOptions, OverlayModule } from '@angular/cdk/overlay';\nimport { ComponentPortal, PortalModule } from '@angular/cdk/portal';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { filter, take } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/overlay';\n\nvar MenuPackage = function MenuPackage(menu, context) {\n  _classCallCheck(this, MenuPackage);\n\n  this.menu = menu;\n  this.context = context;\n};\n\nvar MenuInjector = /*#__PURE__*/function () {\n  function MenuInjector(activeContextMenu, parentInjector, context) {\n    _classCallCheck(this, MenuInjector);\n\n    this.activeContextMenu = activeContextMenu;\n    this.parentInjector = parentInjector;\n    this.context = context;\n    this.menuContext = new MenuPackage(activeContextMenu, context);\n  }\n\n  _createClass(MenuInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue, flags) {\n      if (token === MenuPackage) {\n        return this.menuContext;\n      }\n\n      return this.parentInjector.get(token, notFoundValue, flags);\n    }\n  }]);\n\n  return MenuInjector;\n}();\n\nvar ContextMenuService = /*@__PURE__*/function () {\n  var ContextMenuService = /*#__PURE__*/function () {\n    function ContextMenuService(overlay, scrollStrategy, injector) {\n      _classCallCheck(this, ContextMenuService);\n\n      this.overlay = overlay;\n      this.scrollStrategy = scrollStrategy;\n      this.injector = injector;\n      this.menus = [];\n      this.id = 0;\n    }\n    /**\n     *\n     * @param $event triggering event\n     * @param menuComponent the component to be shown\n     * @param submenu is a menu within a menu\n     * @param level if submenu, what level\n     */\n\n\n    _createClass(ContextMenuService, [{\n      key: \"show\",\n      value: function show($event, menuComponent, context, menuClose, menuAction) {\n        var submenu = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n        var level = arguments.length > 6 ? arguments[6] : undefined;\n        var target;\n\n        if (!submenu) {\n          this.closeAll();\n          target = {\n            getBoundingClientRect: function getBoundingClientRect() {\n              return {\n                bottom: $event.clientY,\n                height: 0,\n                left: $event.clientX,\n                right: $event.clientX,\n                top: $event.clientY,\n                width: 0\n              };\n            }\n          };\n        } else {\n          // close other submenus\n          this.closeAll(undefined, level);\n          target = $event.target;\n        }\n\n        var el = new ElementRef(target);\n        var positionStrategy = this.overlay.position().flexibleConnectedTo(el).withFlexibleDimensions(false);\n\n        if (!submenu) {\n          positionStrategy.withPositions([{\n            originX: 'start',\n            originY: 'bottom',\n            overlayX: 'start',\n            overlayY: 'top'\n          }, {\n            originX: 'start',\n            originY: 'top',\n            overlayX: 'start',\n            overlayY: 'bottom'\n          }, {\n            originX: 'end',\n            originY: 'top',\n            overlayX: 'start',\n            overlayY: 'top'\n          }, {\n            originX: 'start',\n            originY: 'top',\n            overlayX: 'end',\n            overlayY: 'top'\n          }, {\n            originX: 'end',\n            originY: 'center',\n            overlayX: 'start',\n            overlayY: 'center'\n          }, {\n            originX: 'start',\n            originY: 'center',\n            overlayX: 'end',\n            overlayY: 'center'\n          }]);\n        } else {\n          positionStrategy.withPositions([{\n            originX: 'end',\n            originY: 'top',\n            overlayX: 'start',\n            overlayY: 'top'\n          }, {\n            originX: 'start',\n            originY: 'top',\n            overlayX: 'end',\n            overlayY: 'top'\n          }, {\n            originX: 'end',\n            originY: 'bottom',\n            overlayX: 'start',\n            overlayY: 'bottom'\n          }, {\n            originX: 'start',\n            originY: 'bottom',\n            overlayX: 'end',\n            overlayY: 'bottom'\n          }]);\n        }\n\n        var t = {\n          submenu: submenu,\n          id: this.id++,\n          isMenuHovered: new BehaviorSubject(false),\n          isTriggerHovered: new BehaviorSubject(false)\n        };\n        var menuInjector = new MenuInjector(t, this.injector, context);\n        var componentPortal = new ComponentPortal(menuComponent, undefined, menuInjector);\n        var overlayRef = this.overlay.create({\n          positionStrategy: positionStrategy,\n          panelClass: 'ngx-contextmenu',\n          scrollStrategy: this.scrollStrategy.close()\n        });\n        var component = overlayRef.attach(componentPortal);\n        var res = Object.assign(Object.assign({\n          overlayRef: overlayRef,\n          component: component\n        }, t), {\n          menuClose: menuClose,\n          menuAction: menuAction\n        });\n        this.menus.push(res);\n        return res;\n      }\n    }, {\n      key: \"getCurrentLevel\",\n      value: function getCurrentLevel() {\n        return this.menus.length;\n      }\n    }, {\n      key: \"closeAll\",\n      value: function closeAll(context) {\n        var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n        for (var index = idx; index < this.menus.length; index++) {\n          var menu = this.menus[index];\n          this.destroyMenu(menu, context);\n        }\n\n        this.menus.splice(idx, this.menus.length);\n      }\n    }, {\n      key: \"destroyMenu\",\n      value: function destroyMenu(menu, context) {\n        menu.component.instance._state = 'exit';\n\n        if (menu.component.instance.lazy) {\n          menu.component.instance._animationDone.pipe(filter(function (event) {\n            return event.toState === 'exit';\n          }), take(1)).subscribe(function () {\n            menu.overlayRef.detach();\n            menu.overlayRef.dispose();\n          });\n        } else {\n          menu.overlayRef.detach();\n          menu.overlayRef.dispose();\n        }\n\n        if (context) {\n          menu.menuAction.next(context);\n        }\n\n        menu.menuClose.next();\n      }\n    }, {\n      key: \"close\",\n      value: function close(menu, menuIndex, context) {\n        this.destroyMenu(menu, context);\n        this.menus.splice(menuIndex, 1);\n      }\n    }, {\n      key: \"checkOutsideClick\",\n      value: function checkOutsideClick($event) {\n        var _iterator = _createForOfIteratorHelper(this.menus),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var m = _step.value;\n            var clickedInside = m.component.location.nativeElement.contains($event.target);\n\n            if (clickedInside) {\n              $event.preventDefault();\n              $event.stopPropagation();\n              return;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.closeAll();\n      }\n    }, {\n      key: \"closeSubMenu\",\n      value: function closeSubMenu(id) {\n        var menuIndex = this.menus.findIndex(function (n) {\n          return n.id === id;\n        });\n\n        if (menuIndex === -1 || menuIndex !== this.menus.length - 1) {\n          return;\n        } // make sure we can close the current menu\n\n\n        var menu = this.menus[menuIndex];\n\n        if (menu.isMenuHovered.getValue() || menu.isTriggerHovered.getValue()) {\n          return;\n        } // close all menus up if possible\n\n\n        for (var index = this.menus.length - 1; index >= 1; index--) {\n          var m = this.menus[index];\n\n          if (!m.isMenuHovered.getValue() && !m.isTriggerHovered.getValue()) {\n            this.close(m, index);\n          } else {\n            return;\n          }\n        }\n      }\n    }]);\n\n    return ContextMenuService;\n  }();\n\n  ContextMenuService.ɵfac = function ContextMenuService_Factory(t) {\n    return new (t || ContextMenuService)(ɵngcc0.ɵɵinject(ɵngcc1.Overlay), ɵngcc0.ɵɵinject(ɵngcc1.ScrollStrategyOptions), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  ContextMenuService.ɵprov = ɵɵdefineInjectable({\n    factory: function ContextMenuService_Factory() {\n      return new ContextMenuService(ɵɵinject(Overlay), ɵɵinject(ScrollStrategyOptions), ɵɵinject(INJECTOR));\n    },\n    token: ContextMenuService,\n    providedIn: \"root\"\n  });\n  return ContextMenuService;\n}();\n\nvar ContextMenuTriggerDirective = /*@__PURE__*/function () {\n  var ContextMenuTriggerDirective = /*#__PURE__*/function () {\n    function ContextMenuTriggerDirective(contextMenuService) {\n      _classCallCheck(this, ContextMenuTriggerDirective);\n\n      this.contextMenuService = contextMenuService;\n      this.holdToDisplay = 1000;\n      this.menuAction = new EventEmitter();\n      this.menuClose = new EventEmitter();\n      this.beforeOpen = new EventEmitter();\n      this.visible = false;\n    }\n\n    _createClass(ContextMenuTriggerDirective, [{\n      key: \"handleMenu\",\n      value: function handleMenu($event) {\n        var _preventOpen = false;\n        this.beforeOpen.emit({\n          menuContext: this.menuContext,\n          event: $event,\n          preventOpen: function preventOpen() {\n            _preventOpen = true;\n          }\n        });\n\n        if (_preventOpen) {\n          return;\n        }\n\n        $event.preventDefault();\n        this.menu = this.contextMenuService.show($event, this.contextMenuTrigger, this.menuContext, this.menuClose, this.menuAction);\n        this.visible = true;\n      }\n    }, {\n      key: \"handleMouseDown\",\n      value: function handleMouseDown($event) {\n        var _this = this;\n\n        if (this.holdToDisplay >= 0) {\n          $event.stopPropagation();\n          $event.clientY = $event.touches[0].clientY;\n          $event.clientX = $event.touches[0].clientX;\n          this.mouseDownTimeoutId = setTimeout(function () {\n            return _this.handleMenu($event);\n          }, this.holdToDisplay);\n        }\n      }\n    }, {\n      key: \"handleMouseUp\",\n      value: function handleMouseUp() {\n        clearTimeout(this.mouseDownTimeoutId);\n      }\n    }, {\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this2 = this;\n\n        this.sub = this.menuClose.subscribe(function () {\n          return _this2.visible = false;\n        });\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.sub.unsubscribe();\n      }\n    }]);\n\n    return ContextMenuTriggerDirective;\n  }();\n\n  ContextMenuTriggerDirective.ɵfac = function ContextMenuTriggerDirective_Factory(t) {\n    return new (t || ContextMenuTriggerDirective)(ɵngcc0.ɵɵdirectiveInject(ContextMenuService));\n  };\n\n  ContextMenuTriggerDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ContextMenuTriggerDirective,\n    selectors: [[\"\", \"contextMenuTrigger\", \"\"]],\n    hostBindings: function ContextMenuTriggerDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"contextmenu\", function ContextMenuTriggerDirective_contextmenu_HostBindingHandler($event) {\n          return ctx.handleMenu($event);\n        })(\"touchstart\", function ContextMenuTriggerDirective_touchstart_HostBindingHandler($event) {\n          return ctx.handleMouseDown($event);\n        })(\"touchend\", function ContextMenuTriggerDirective_touchend_HostBindingHandler() {\n          return ctx.handleMouseUp();\n        });\n      }\n    },\n    inputs: {\n      holdToDisplay: \"holdToDisplay\",\n      contextMenuTrigger: \"contextMenuTrigger\",\n      menuContext: \"menuContext\"\n    },\n    outputs: {\n      menuAction: \"menuAction\",\n      menuClose: \"menuClose\",\n      beforeOpen: \"beforeOpen\"\n    },\n    exportAs: [\"contextMenuTrigger\"]\n  });\n  return ContextMenuTriggerDirective;\n}();\n\nvar ContextSubmenuTriggerDirective = /*@__PURE__*/function () {\n  var ContextSubmenuTriggerDirective = /*#__PURE__*/function () {\n    function ContextSubmenuTriggerDirective(contextMenuService) {\n      var _this3 = this;\n\n      _classCallCheck(this, ContextSubmenuTriggerDirective);\n\n      this.contextMenuService = contextMenuService;\n      this.hoverDelay = 500;\n      this.openDelay = 200;\n      this.menuAction = new EventEmitter();\n      this.menuClose = new EventEmitter();\n      this.visible = false;\n      this.level = 1; // get current level\n\n      setTimeout(function () {\n        return _this3.level = _this3.contextMenuService.getCurrentLevel();\n      });\n    }\n\n    _createClass(ContextSubmenuTriggerDirective, [{\n      key: \"handleSubMenuClick\",\n      value: function handleSubMenuClick($event) {\n        $event.preventDefault();\n        $event.stopPropagation();\n        clearTimeout(this.opentimer);\n        clearTimeout(this.closetimer);\n        this.menu = this.contextMenuService.show($event, this.contextSubmenuTrigger, this.menuContext, this.menuClose, this.menuAction, true, this.level);\n        this.visible = true;\n      }\n    }, {\n      key: \"handleSubMenuEnter\",\n      value: function handleSubMenuEnter($event) {\n        var _this4 = this;\n\n        if (this.menu) {\n          this.menu.isTriggerHovered.next(true);\n        }\n\n        clearTimeout(this.closetimer);\n        this.opentimer = setTimeout(function () {\n          _this4.menu = _this4.contextMenuService.show($event, _this4.contextSubmenuTrigger, _this4.menuContext, _this4.menuClose, _this4.menuAction, true, _this4.level);\n          _this4.visible = true;\n          _this4.opentimer = null;\n        }, this.openDelay);\n      }\n      /**\n       * submenu hides after cursor has exited for a period of time\n       */\n\n    }, {\n      key: \"handleSubMenuExit\",\n      value: function handleSubMenuExit() {\n        var _this5 = this;\n\n        clearTimeout(this.opentimer);\n\n        if (this.menu) {\n          this.menu.isTriggerHovered.next(false);\n        }\n\n        this.closetimer = setTimeout(function () {\n          if (_this5.menu) {\n            _this5.menu.isTriggerHovered.next(false);\n\n            _this5.contextMenuService.closeSubMenu(_this5.menu.id);\n\n            _this5.menu = undefined;\n          }\n\n          _this5.visible = false;\n        }, this.hoverDelay);\n      }\n      /**\n       * if overwritten make sure to clear timeouts\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        clearTimeout(this.opentimer);\n        clearTimeout(this.closetimer);\n      }\n    }]);\n\n    return ContextSubmenuTriggerDirective;\n  }();\n\n  ContextSubmenuTriggerDirective.ɵfac = function ContextSubmenuTriggerDirective_Factory(t) {\n    return new (t || ContextSubmenuTriggerDirective)(ɵngcc0.ɵɵdirectiveInject(ContextMenuService));\n  };\n\n  ContextSubmenuTriggerDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ContextSubmenuTriggerDirective,\n    selectors: [[\"\", \"contextSubmenuTrigger\", \"\"]],\n    hostBindings: function ContextSubmenuTriggerDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function ContextSubmenuTriggerDirective_click_HostBindingHandler($event) {\n          return ctx.handleSubMenuClick($event);\n        })(\"mouseover\", function ContextSubmenuTriggerDirective_mouseover_HostBindingHandler($event) {\n          return ctx.handleSubMenuEnter($event);\n        })(\"mouseout\", function ContextSubmenuTriggerDirective_mouseout_HostBindingHandler() {\n          return ctx.handleSubMenuExit();\n        });\n      }\n    },\n    inputs: {\n      hoverDelay: \"hoverDelay\",\n      openDelay: \"openDelay\",\n      contextSubmenuTrigger: \"contextSubmenuTrigger\",\n      menuContext: \"menuContext\"\n    },\n    outputs: {\n      menuAction: \"menuAction\",\n      menuClose: \"menuClose\"\n    }\n  });\n  return ContextSubmenuTriggerDirective;\n}();\n\nvar MenuComponent = /*@__PURE__*/function () {\n  var MenuComponent = /*#__PURE__*/function () {\n    function MenuComponent(menuPackage, contextMenuService) {\n      _classCallCheck(this, MenuComponent);\n\n      this.menuPackage = menuPackage;\n      this.contextMenuService = contextMenuService;\n      /** State of the dialog animation. */\n\n      this._state = 'enter';\n      this._animationDone = new Subject();\n      /** set lazy to False if you do not have animations */\n\n      this.lazy = true;\n    }\n\n    _createClass(MenuComponent, [{\n      key: \"handleMouseover\",\n      value: function handleMouseover() {\n        if (!this.menuPackage.menu.submenu) {\n          return;\n        }\n\n        this.menuPackage.menu.isMenuHovered.next(true);\n        clearTimeout(this.closetimer);\n      }\n    }, {\n      key: \"handleMouseleave\",\n      value: function handleMouseleave() {\n        var _this6 = this;\n\n        if (!this.menuPackage.menu.submenu) {\n          return;\n        }\n\n        this.menuPackage.menu.isMenuHovered.next(false);\n        this.closetimer = setTimeout(function () {\n          _this6.contextMenuService.closeSubMenu(_this6.menuPackage.menu.id);\n        }, 500);\n      }\n    }, {\n      key: \"handleWindowClick\",\n      value: function handleWindowClick($event) {\n        this.contextMenuService.checkOutsideClick($event);\n      }\n      /** Callback that is invoked when the menu animation completes. */\n\n    }, {\n      key: \"_onAnimationDone\",\n      value: function _onAnimationDone(event) {\n        this._animationDone.next(event);\n      }\n    }]);\n\n    return MenuComponent;\n  }();\n\n  MenuComponent.ɵfac = function MenuComponent_Factory(t) {\n    return new (t || MenuComponent)(ɵngcc0.ɵɵdirectiveInject(MenuPackage), ɵngcc0.ɵɵdirectiveInject(ContextMenuService));\n  };\n\n  MenuComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MenuComponent,\n    selectors: [[\"app-menu\"]],\n    hostBindings: function MenuComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵsyntheticHostListener(\"@menu.done\", function MenuComponent_animation_menu_done_HostBindingHandler($event) {\n          return ctx._onAnimationDone($event);\n        });\n        ɵngcc0.ɵɵlistener(\"mouseover\", function MenuComponent_mouseover_HostBindingHandler() {\n          return ctx.handleMouseover();\n        })(\"mouseleave\", function MenuComponent_mouseleave_HostBindingHandler() {\n          return ctx.handleMouseleave();\n        })(\"click\", function MenuComponent_click_HostBindingHandler($event) {\n          return ctx.handleWindowClick($event);\n        }, false, ɵngcc0.ɵɵresolveDocument);\n      }\n    },\n    decls: 0,\n    vars: 0,\n    template: function MenuComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return MenuComponent;\n}();\n\nvar ContextMenuModule = /*@__PURE__*/function () {\n  var ContextMenuModule = function ContextMenuModule() {\n    _classCallCheck(this, ContextMenuModule);\n  };\n\n  ContextMenuModule.ɵfac = function ContextMenuModule_Factory(t) {\n    return new (t || ContextMenuModule)();\n  };\n\n  ContextMenuModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ContextMenuModule\n  });\n  ContextMenuModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[PortalModule, OverlayModule]]\n  });\n  return ContextMenuModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ContextMenuModule, {\n    declarations: function declarations() {\n      return [ContextMenuTriggerDirective, ContextSubmenuTriggerDirective, MenuComponent];\n    },\n    imports: function imports() {\n      return [PortalModule, OverlayModule];\n    },\n    exports: function exports() {\n      return [ContextMenuTriggerDirective, ContextSubmenuTriggerDirective];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ContextMenuModule, ContextMenuService, ContextMenuTriggerDirective, ContextSubmenuTriggerDirective, MenuComponent, MenuInjector, MenuPackage }; //# sourceMappingURL=ctrl-ngx-rightclick.js.map","map":null,"metadata":{},"sourceType":"module"}