{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/mac/Apps/sr-manager/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/mac/Apps/sr-manager/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/mac/Apps/sr-manager/frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { BYTE } from './byte';\n/**\n * Frame class represents a STOMP frame.\n *\n * @internal\n */\n\nexport var FrameImpl = /*#__PURE__*/function () {\n  /**\n   * Frame constructor. `command`, `headers` and `body` are available as properties.\n   *\n   * @internal\n   */\n  function FrameImpl(params) {\n    _classCallCheck(this, FrameImpl);\n\n    var command = params.command,\n        headers = params.headers,\n        body = params.body,\n        binaryBody = params.binaryBody,\n        escapeHeaderValues = params.escapeHeaderValues,\n        skipContentLengthHeader = params.skipContentLengthHeader;\n    this.command = command;\n    this.headers = Object.assign({}, headers || {});\n\n    if (binaryBody) {\n      this._binaryBody = binaryBody;\n      this.isBinaryBody = true;\n    } else {\n      this._body = body || '';\n      this.isBinaryBody = false;\n    }\n\n    this.escapeHeaderValues = escapeHeaderValues || false;\n    this.skipContentLengthHeader = skipContentLengthHeader || false;\n  }\n  /**\n   * body of the frame\n   */\n\n\n  _createClass(FrameImpl, [{\n    key: \"body\",\n    get: function get() {\n      if (!this._body && this.isBinaryBody) {\n        this._body = new TextDecoder().decode(this._binaryBody);\n      }\n\n      return this._body;\n    }\n    /**\n     * body as Uint8Array\n     */\n\n  }, {\n    key: \"binaryBody\",\n    get: function get() {\n      if (!this._binaryBody && !this.isBinaryBody) {\n        this._binaryBody = new TextEncoder().encode(this._body);\n      }\n\n      return this._binaryBody;\n    }\n    /**\n     * deserialize a STOMP Frame from raw data.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"toString\",\n    value:\n    /**\n     * @internal\n     */\n    function toString() {\n      return this.serializeCmdAndHeaders();\n    }\n    /**\n     * serialize this Frame in a format suitable to be passed to WebSocket.\n     * If the body is string the output will be string.\n     * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var cmdAndHeaders = this.serializeCmdAndHeaders();\n\n      if (this.isBinaryBody) {\n        return FrameImpl.toUnit8Array(cmdAndHeaders, this._binaryBody).buffer;\n      } else {\n        return cmdAndHeaders + this._body + BYTE.NULL;\n      }\n    }\n  }, {\n    key: \"serializeCmdAndHeaders\",\n    value: function serializeCmdAndHeaders() {\n      var lines = [this.command];\n\n      if (this.skipContentLengthHeader) {\n        delete this.headers['content-length'];\n      }\n\n      for (var _i = 0, _Object$keys = Object.keys(this.headers || {}); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n        var value = this.headers[name];\n\n        if (this.escapeHeaderValues && this.command !== 'CONNECT' && this.command !== 'CONNECTED') {\n          lines.push(\"\".concat(name, \":\").concat(FrameImpl.hdrValueEscape(\"\".concat(value))));\n        } else {\n          lines.push(\"\".concat(name, \":\").concat(value));\n        }\n      }\n\n      if (this.isBinaryBody || !this.isBodyEmpty() && !this.skipContentLengthHeader) {\n        lines.push(\"content-length:\".concat(this.bodyLength()));\n      }\n\n      return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\n    }\n  }, {\n    key: \"isBodyEmpty\",\n    value: function isBodyEmpty() {\n      return this.bodyLength() === 0;\n    }\n  }, {\n    key: \"bodyLength\",\n    value: function bodyLength() {\n      var binaryBody = this.binaryBody;\n      return binaryBody ? binaryBody.length : 0;\n    }\n    /**\n     * Compute the size of a UTF-8 string by counting its number of bytes\n     * (and not the number of characters composing the string)\n     */\n\n  }], [{\n    key: \"fromRawFrame\",\n    value: function fromRawFrame(rawFrame, escapeHeaderValues) {\n      var headers = {};\n\n      var trim = function trim(str) {\n        return str.replace(/^\\s+|\\s+$/g, '');\n      }; // In case of repeated headers, as per standards, first value need to be used\n\n\n      var _iterator = _createForOfIteratorHelper(rawFrame.headers.reverse()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var header = _step.value;\n          var idx = header.indexOf(':');\n          var key = trim(header[0]);\n          var value = trim(header[1]);\n\n          if (escapeHeaderValues && rawFrame.command !== 'CONNECT' && rawFrame.command !== 'CONNECTED') {\n            value = FrameImpl.hdrValueUnEscape(value);\n          }\n\n          headers[key] = value;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return new FrameImpl({\n        command: rawFrame.command,\n        headers: headers,\n        binaryBody: rawFrame.binaryBody,\n        escapeHeaderValues: escapeHeaderValues\n      });\n    }\n  }, {\n    key: \"sizeOfUTF8\",\n    value: function sizeOfUTF8(s) {\n      return s ? new TextEncoder().encode(s).length : 0;\n    }\n  }, {\n    key: \"toUnit8Array\",\n    value: function toUnit8Array(cmdAndHeaders, binaryBody) {\n      var uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n      var nullTerminator = new Uint8Array([0]);\n      var uint8Frame = new Uint8Array(uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length);\n      uint8Frame.set(uint8CmdAndHeaders);\n      uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n      uint8Frame.set(nullTerminator, uint8CmdAndHeaders.length + binaryBody.length);\n      return uint8Frame;\n    }\n    /**\n     * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"marshall\",\n    value: function marshall(params) {\n      var frame = new FrameImpl(params);\n      return frame.serialize();\n    }\n    /**\n     *  Escape header values\n     */\n\n  }, {\n    key: \"hdrValueEscape\",\n    value: function hdrValueEscape(str) {\n      return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n').replace(/:/g, '\\\\c');\n    }\n    /**\n     * UnEscape header values\n     */\n\n  }, {\n    key: \"hdrValueUnEscape\",\n    value: function hdrValueUnEscape(str) {\n      return str.replace(/\\\\r/g, '\\r').replace(/\\\\n/g, '\\n').replace(/\\\\c/g, ':').replace(/\\\\\\\\/g, '\\\\');\n    }\n  }]);\n\n  return FrameImpl;\n}(); //# sourceMappingURL=frame-impl.js.map","map":{"version":3,"sources":["/Users/mac/Apps/sr-manager/frontend/node_modules/@stomp/stompjs/esm6/frame-impl.js"],"names":["BYTE","FrameImpl","params","command","headers","body","binaryBody","escapeHeaderValues","skipContentLengthHeader","Object","assign","_binaryBody","isBinaryBody","_body","TextDecoder","decode","TextEncoder","encode","serializeCmdAndHeaders","cmdAndHeaders","toUnit8Array","buffer","NULL","lines","keys","name","value","push","hdrValueEscape","isBodyEmpty","bodyLength","join","LF","length","rawFrame","trim","str","replace","reverse","header","idx","indexOf","key","hdrValueUnEscape","s","uint8CmdAndHeaders","nullTerminator","Uint8Array","uint8Frame","set","frame","serialize"],"mappings":"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","sourcesContent":["import { BYTE } from './byte';\n/**\n * Frame class represents a STOMP frame.\n *\n * @internal\n */\nexport class FrameImpl {\n    /**\n     * Frame constructor. `command`, `headers` and `body` are available as properties.\n     *\n     * @internal\n     */\n    constructor(params) {\n        const { command, headers, body, binaryBody, escapeHeaderValues, skipContentLengthHeader, } = params;\n        this.command = command;\n        this.headers = Object.assign({}, headers || {});\n        if (binaryBody) {\n            this._binaryBody = binaryBody;\n            this.isBinaryBody = true;\n        }\n        else {\n            this._body = body || '';\n            this.isBinaryBody = false;\n        }\n        this.escapeHeaderValues = escapeHeaderValues || false;\n        this.skipContentLengthHeader = skipContentLengthHeader || false;\n    }\n    /**\n     * body of the frame\n     */\n    get body() {\n        if (!this._body && this.isBinaryBody) {\n            this._body = new TextDecoder().decode(this._binaryBody);\n        }\n        return this._body;\n    }\n    /**\n     * body as Uint8Array\n     */\n    get binaryBody() {\n        if (!this._binaryBody && !this.isBinaryBody) {\n            this._binaryBody = new TextEncoder().encode(this._body);\n        }\n        return this._binaryBody;\n    }\n    /**\n     * deserialize a STOMP Frame from raw data.\n     *\n     * @internal\n     */\n    static fromRawFrame(rawFrame, escapeHeaderValues) {\n        const headers = {};\n        const trim = (str) => str.replace(/^\\s+|\\s+$/g, '');\n        // In case of repeated headers, as per standards, first value need to be used\n        for (const header of rawFrame.headers.reverse()) {\n            const idx = header.indexOf(':');\n            const key = trim(header[0]);\n            let value = trim(header[1]);\n            if (escapeHeaderValues &&\n                rawFrame.command !== 'CONNECT' &&\n                rawFrame.command !== 'CONNECTED') {\n                value = FrameImpl.hdrValueUnEscape(value);\n            }\n            headers[key] = value;\n        }\n        return new FrameImpl({\n            command: rawFrame.command,\n            headers,\n            binaryBody: rawFrame.binaryBody,\n            escapeHeaderValues,\n        });\n    }\n    /**\n     * @internal\n     */\n    toString() {\n        return this.serializeCmdAndHeaders();\n    }\n    /**\n     * serialize this Frame in a format suitable to be passed to WebSocket.\n     * If the body is string the output will be string.\n     * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n     *\n     * @internal\n     */\n    serialize() {\n        const cmdAndHeaders = this.serializeCmdAndHeaders();\n        if (this.isBinaryBody) {\n            return FrameImpl.toUnit8Array(cmdAndHeaders, this._binaryBody).buffer;\n        }\n        else {\n            return cmdAndHeaders + this._body + BYTE.NULL;\n        }\n    }\n    serializeCmdAndHeaders() {\n        const lines = [this.command];\n        if (this.skipContentLengthHeader) {\n            delete this.headers['content-length'];\n        }\n        for (const name of Object.keys(this.headers || {})) {\n            const value = this.headers[name];\n            if (this.escapeHeaderValues &&\n                this.command !== 'CONNECT' &&\n                this.command !== 'CONNECTED') {\n                lines.push(`${name}:${FrameImpl.hdrValueEscape(`${value}`)}`);\n            }\n            else {\n                lines.push(`${name}:${value}`);\n            }\n        }\n        if (this.isBinaryBody ||\n            (!this.isBodyEmpty() && !this.skipContentLengthHeader)) {\n            lines.push(`content-length:${this.bodyLength()}`);\n        }\n        return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\n    }\n    isBodyEmpty() {\n        return this.bodyLength() === 0;\n    }\n    bodyLength() {\n        const binaryBody = this.binaryBody;\n        return binaryBody ? binaryBody.length : 0;\n    }\n    /**\n     * Compute the size of a UTF-8 string by counting its number of bytes\n     * (and not the number of characters composing the string)\n     */\n    static sizeOfUTF8(s) {\n        return s ? new TextEncoder().encode(s).length : 0;\n    }\n    static toUnit8Array(cmdAndHeaders, binaryBody) {\n        const uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n        const nullTerminator = new Uint8Array([0]);\n        const uint8Frame = new Uint8Array(uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length);\n        uint8Frame.set(uint8CmdAndHeaders);\n        uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n        uint8Frame.set(nullTerminator, uint8CmdAndHeaders.length + binaryBody.length);\n        return uint8Frame;\n    }\n    /**\n     * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n     *\n     * @internal\n     */\n    static marshall(params) {\n        const frame = new FrameImpl(params);\n        return frame.serialize();\n    }\n    /**\n     *  Escape header values\n     */\n    static hdrValueEscape(str) {\n        return str\n            .replace(/\\\\/g, '\\\\\\\\')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/:/g, '\\\\c');\n    }\n    /**\n     * UnEscape header values\n     */\n    static hdrValueUnEscape(str) {\n        return str\n            .replace(/\\\\r/g, '\\r')\n            .replace(/\\\\n/g, '\\n')\n            .replace(/\\\\c/g, ':')\n            .replace(/\\\\\\\\/g, '\\\\');\n    }\n}\n//# sourceMappingURL=frame-impl.js.map"]},"metadata":{},"sourceType":"module"}